# Screw-UP

Viteプラグイン向けのシンプルなパッケージメタデータ挿入ツール。

[![Project Status: WIP – Initial development is in progress, but there has not yet been a stable, usable release suitable for the public.](https://www.repostatus.org/badges/latest/wip.svg)](https://www.repostatus.org/#wip)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![npm version](https://img.shields.io/npm/v/screw-up.svg)](https://www.npmjs.com/package/screw-up)

----

[In English](./README.md)

## これは何ですか？

これは、パッケージメタデータ（名前、バージョン、説明、作者、ライセンスなど）を含むバナーコメントをバンドルされたファイルに自動的に挿入するViteプラグインです。

このプラグインは自動的に`package.json`からメタデータを読み取ります:

```json
{
  "name": "my-awesome-library",
  "version": "2.1.0",
  "description": "An awesome TypeScript library",
  "author": "Jane Developer <jane@example.com>",
  "license": "Apache-2.0",
  "repository": {
    "url": "https://github.com/user/my-awesome-library"
  }
}
```

各バンドルされたソースファイル（`dist/index.js`など）にバナーヘッダーを挿入します：

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * description: An awesome TypeScript library
 * author: Jane Developer <jane@example.com>
 * license: Apache-2.0
 * repository.url: https://github.com/user/my-awesome-library
 * git.commit.hash: c94eaf71dcc6522aae593c7daf85bb745112caf0
 */
// Your bundled code here...
```

## 主な機能

* 自動メタデータ抽出: `package.json`から自動的にメタデータを読み取ります。
* ワークスペースサポート: モノレポで動作し、親パッケージからメタデータを自動的に継承します。
* 柔軟な出力: 含めるキーとその順序を正確に指定できます。
* ネストされたオブジェクトサポート: `author.name`、`repository.url`などのネストされたオブジェクトを処理します。
* カスタマイズ可能: バナーに含めるメタデータフィールドを選択できます。
* TypeScriptメタデータ生成: ソースコードで使用するメタデータ定数を含むTypeScriptファイルを自動生成出来ます。
* Gitメタデータ抽出: ローカルGitリポジトリからGitコミットハッシュ、タグ、ブランチ、バージョン情報を自動的に抽出します。
* pack/publish CLIインターフェースをサポート: この機能を使用して公開する際、`package.json`に上記の処理を適用した後にパッケージが生成されます。

----

## インストール

`devDependency`にインストールして下さい。Screw-UPは実行時のコードを必要としません。

```bash
npm install --save-dev screw-up
```

## 使い方

### Viteプラグインの準備

`vite.config.ts`にプラグインを追加します:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp()  // デフォルトの出力キーを使用
  ],
  // ...
});
```

`outputKeys`が指定されていない場合、プラグインは以下のメタデータキーをこの順序で使用します:
`name`, `version`, `description`, `author`, `license`, `repository.url`, `git.commit.hash`.

### カスタム出力キー

含めるメタデータフィールドとその順序を指定できます:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      outputKeys: ['name', 'version', 'license']  // これらのフィールドのみを含める
    })
  ],
  // ...
});
```

これにより、指定されたフィールドのみを含むバナーが生成されます:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * license: Apache-2.0
 */
```

### ネストされたオブジェクトの操作

プラグインはドット記法を使用することで、ネストされたオブジェクトを自動的にフラット化します。
以下のような`package.json`定義がある場合:

```json
{
  "name": "my-package",
  "author": {   // ネストしたメタデータ
    "name": "Jane Developer",
    "email": "jane@example.com"
  },
  "repository": {   // ネストしたメタデータ
    "type": "git",
    "url": "https://github.com/user/my-package"
  }
}
```

`outputKeys`でネストされたフィールドを参照できます:

```typescript
screwUp({
  outputKeys: ['name', 'author.name', 'author.email', 'repository.url']
})
```

結果:

```javascript
/*!
 * name: my-package
 * author.name: Jane Developer
 * author.email: jane@example.com
 * repository.url: https://github.com/user/my-package
 */
```

### TypeScriptメタデータ生成

プラグインは、インポートして使用できるメタデータ定数を含む、TypeScriptファイルを生成できます:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      // メタデータファイル生成を有効化
      outputMetadataFile: true,
      // カスタムパス（オプション）
      outputMetadataFilePath: 'src/generated/packageMetadata.ts',
      // 含めるキー（オプション）
      outputMetadataKeys: ['name', 'version', 'description', 'author', 'license']
    })
  ],
  // ...
});
```

これにより、TypeScript定数を含む`src/generated/packageMetadata.ts`が生成されます：

```typescript
// This file is auto-generated by screw-up plugin
// Do not edit manually

export const name = "my-awesome-library";
export const version = "2.1.0";
export const description = "An awesome TypeScript library";
export const author = "Jane Developer <jane@example.com>";
export const license = "Apache-2.0";
```

その後、これらの定数をソースコードでインポートして使用できます:

```typescript
import { name, version } from './generated/packageMetadata.js';

// Output: my-awesome-library v2.1.0
console.log(`${name} v${version}`);

export function getLibraryInfo() {
  return { name, version };
}
```

#### キーのサニタイズ

特殊文字を含むキーは、有効なTypeScript識別子に自動的にサニタイズされます:

- `repository.url` → `repository_url`
- `custom-key` → `custom_key`
- `123invalid` → `_123invalid`

### Gitメタデータ

プラグインは、ローカルGitリポジトリからGitメタデータを自動的に抽出し、メタデータキーとして利用可能にします。

#### 利用可能なGitメタデータ

- `git.version`: Gitタグとコミット深さに基づいて、自動的に計算されたバージョン
- `git.commit.hash`: 現在のコミットの完全なコミットハッシュ
- `git.commit.short`: 短いコミットハッシュ（最初の7文字）
- `git.commit.date`: ISO形式のコミット日時
- `git.commit.message`: コミットメッセージ
- `git.tags`: 現在のコミットを指すすべてのタグの配列
- `git.branches`: 現在のコミットを含むブランチの配列

#### バージョン計算

Gitバージョン計算は以下のアルゴリズムに従います:

1. タグ付きコミット: タグバージョンを直接使用（例: `v1.2.3` --> `1.2.3`）
2. タグなしコミット: 最も遠い祖先タグまでの深さを検出して、最後のバージョンコンポーネントをインクリメント
3. 変更されたワーキングディレクトリ: 未コミットの変更が存在する場合、バージョンを1つインクリメント
4. タグが見つからない場合: デフォルトで`0.0.1`とし、各コミットに対してインクリメント

更に、この計算結果は `package.json` の `version` キーのデフォルト値として適用されます。
従って、 `package.json` に `version` キーを含めずに、GitタグとScrew-UPを使用してバージョン番号の管理を行うことが出来ます。

Gitメタデータを含む例:

```typescript
screwUp({
  outputKeys: ['name', 'version', 'git.version', 'git.commit.hash', 'git.commit.short']
})
```

結果:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * git.version: 1.2.4
 * git.commit.hash: c94eaf71dcc6522aae593c7daf85bb745112caf0
 * git.commit.short: c94eaf7
 */
```

----

## 高度な使用方法

### モノレポサポート

プラグインは、ワークスペース設定を自動的に検出し、親パッケージからメタデータを継承します:

```
my-monorepo/
├── package.json          # 共有メタデータを持つルートパッケージ
├── packages/
│   ├── ui/
│   │   └── package.json  # 子パッケージ
│   └── core/
│       └── package.json  # 子パッケージ
```

子パッケージは、特定のフィールドをオーバーライドする機能を持ちながら、ルートパッケージからメタデータを自動的に継承します:

```json
// ルートのpackage.json
{
  "name": "my-monorepo",
  "version": "1.0.0",
  "author": "Company Team",
  "license": "MIT"
}

// packages/ui/package.json
{
  "name": "@my-monorepo/ui",
  "description": "UI components library"
}
```

UIパッケージをビルドすると、バナーには以下が含まれます:

```javascript
/*!
 * name: @my-monorepo/ui
 * version: 1.0.0
 * description: UI components library
 * author: Company Team
 * license: MIT
 */
```

## サポートされるワークスペースタイプ

プラグインは以下を自動的に検出してサポートします：

- npm/yarnワークスペース：`package.json`の`workspaces`フィールドで検出
- pnpmワークスペース：`pnpm-workspace.yaml`ファイルで検出
- Lerna：`lerna.json`ファイルで検出

----

## CLI使用方法

`screw-up`パッケージには、プロジェクトのパッケージ化と公開のためのコマンドラインインターフェースが含まれています。

### シンプルな例

```bash
# ドライランでビルドして公開
screw-up publish --dry-run

# ベータチャンネルに公開
screw-up publish --tag beta

# スコープ付きパッケージをパブリックとして公開
screw-up publish --access public

# カスタムREADMEと限定継承でパック
screw-up pack --readme ./docs/DIST_README.md --inheritable-fields "version,license"

# パッケージ解決をデバッグ
screw-up dump --inheritable-fields "version,author"

# カスタムディレクトリにパックしてから公開
screw-up pack --pack-destination ./release
screw-up publish ./release/my-package-1.0.0.tgz
```

任意のコマンドのヘルプについて：

```bash
screw-up --help
screw-up pack --help
screw-up publish --help
screw-up dump --help
```

### packコマンド

プロジェクトのtarアーカイブを作成します：

```bash
# 現在のディレクトリをパック
screw-up pack

# 特定のディレクトリをパック
screw-up pack ./my-project

# 特定の出力ディレクトリにパック
screw-up pack --pack-destination ./dist
```

packコマンドの機能：

- メタデータとファイル包含ルールのために`package.json`を自動的に読み取り
- `package.json`の`files`フィールドを尊重
- ワークスペース継承をサポート（親パッケージからメタデータを継承）
- `{name}-{version}.tgz`形式で圧縮された`.tgz`アーカイブを作成

#### オプション

- `--pack-destination <path>`：アーカイブの出力ディレクトリを指定
- `--readme <path>`：README.mdを指定したファイルで置換
- `--inheritable-fields <list>`：親から継承するフィールドのコンマ区切りリスト（デフォルト: version,description,author,license,repository,keywords,homepage,bugs,readme）
- `--no-wds`：バージョンインクリメントのワーキングディレクトリステータスチェックを無効化

### publishコマンド

プロジェクトをレジストリサーバーに公開します:

```bash
# 現在のディレクトリを公開（アーカイブを作成して公開）
screw-up publish

# 特定のディレクトリを公開
screw-up publish ./my-project

# 既存のtarballを公開
screw-up publish package.tgz

# npmオプション付きで公開（すべてのnpm publishオプションがサポートされています）
screw-up publish --dry-run --tag beta --access public
```

publishコマンドの機能：

- すべての`npm publish`オプションを透過的にサポート。このコマンドは、アーカイブ生成を行った後、実際の発行処理を`npm publish`を呼び出すことで実行します。
- ディレクトリから公開（自動的にアーカイブを作成）または既存のtarballから公開可能
- 適切なメタデータ継承でワークスペースパッケージを処理
- packコマンドと同じパッケージ化ロジックを使用

#### オプション

- `--inheritable-fields <list>`：親から継承するフィールドのコンマ区切りリスト
- `--no-wds`：バージョンインクリメントのワーキングディレクトリステータスチェックを無効化
- すべての`npm publish`オプションがサポートされています（例：`--dry-run`、`--tag`、`--access`、`--registry`）

### dumpコマンド

計算されたpackage.jsonをJSONとして出力します：

```bash
# 現在のディレクトリのpackage.jsonを出力
screw-up dump

# 特定のディレクトリのpackage.jsonを出力
screw-up dump ./my-project

# カスタム継承フィールドで出力
screw-up dump --inheritable-fields "author,license"
```

dumpコマンドの機能：

- すべての処理（ワークスペース継承、Gitメタデータなど）後の最終的な計算済み`package.json`を表示
- デバッグとパッケージメタデータの解決方法の理解に有用
- 他のツールにパイプできるクリーンなJSONを出力

#### オプション

- `--inheritable-fields <list>`：親から継承するフィールドのコンマ区切りリスト
- `--no-wds`：バージョンインクリメントのワーキングディレクトリステータスチェックを無効化

### README置換

packコマンドは複数の方法でREADME置換をサポートします：

#### CLIオプション経由

```bash
# README.mdをカスタムファイルで置換
screw-up pack --readme ./docs/README_package.md
```

#### package.jsonフィールド経由

```json
{
  "name": "my-package",
  "readme": "docs/PACKAGE_README.md"
}
```

両方が指定された場合、`--readme` CLIオプションが`package.json`フィールドより優先されます。

### ワークスペースフィールド継承

モノレポで親パッケージから継承するメタデータフィールドを制御します：

```bash
# 特定のフィールドのみ継承
screw-up pack --inheritable-fields "version,author,license"

# 継承を完全に無効化
screw-up pack --inheritable-fields ""

# 公開時にカスタムフィールドを使用
screw-up publish --inheritable-fields "version,description,keywords"
```

デフォルト継承フィールド：`version`、`description`、`author`、`license`、`repository`、`keywords`、`homepage`、`bugs`、`readme`

----

## 補足

このプロジェクトは [RelaxVersioner](https://github.com/kekyo/RelaxVersioner/) の後継として開発されました。RelaxVersionerは.NETプラットフォーム向けで、NPMサポートオプションを追加しました。しかし、Gitタグとの親和性があまり良くないため、Viteプラグインを使用することを前提として、最も望ましい運用を想定して仕様を検討しました。

## ライセンス

MIT