# screw-up

NPM向けの、シンプルなパッケージメタデータ挿入ツール

![screw-up](images/screw-up-120.png)

[![Project Status: Active – The project has reached a stable, usable state and is being actively developed.](https://www.repostatus.org/badges/latest/active.svg)](https://www.repostatus.org/#active)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![npm version](https://img.shields.io/npm/v/screw-up.svg)](https://www.npmjs.com/package/screw-up)

---

[In English](./README.md)

## これは何ですか？

バージョンをTypeScriptプロジェクトやNPMパッケージに適用する、シンプルなソリューションを探していますか？
`screw-up` はあたなが必要とするツールになり得ます。

これは、パッケージメタデータ（名前、バージョン、説明、作者、ライセンスなど）を含むバナーコメントをバンドルされたファイルに自動的に挿入するViteプラグインと、NPMパッケージに適用するCLIツールです。

Viteプラグインは、自動的に`package.json`からメタデータを読み取ります:

```json
{
  "name": "my-awesome-library",
  "version": "2.1.0",
  "description": "An awesome TypeScript library",
  "author": "Jane Developer <jane@example.com>",
  "license": "Apache-2.0",
  "repository": {
    "url": "https://github.com/user/my-awesome-library"
  }
}
```

各バンドルされたソースファイル（`dist/index.js`など）にバナーヘッダーを挿入します：

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * description: An awesome TypeScript library
 * author: Jane Developer <jane@example.com>
 * license: Apache-2.0
 * repository.url: https://github.com/user/my-awesome-library
 * git.commit.hash: c94eaf71dcc6522aae593c7daf85bb745112caf0
 */
// Your bundled code here...
```

`git.commit.hash:`という行に気がついたかもしれません。そうです、プロジェクトがGitで管理されている場合（管理していますよね？）、そのコミットIDやブランチ・タグの情報を挿入させることもできます。
そして最も重要なのは、Gitタグにバージョンが適用されている場合、そのバージョンタグを自動的に `package.json` の `version` に反映させることができます。つまり、Gitタグだけを使って、バージョン番号の管理ができます!

`npm pack` ではなく、CLIツール `screw-up` を使ってパッケージを生成すれば、収集されたメタデータをNPMパッケージの `package.json` に自動で適用できます:

```bash
# `screw-up`コマンドを使ってパッケージを生成
$ screw-up pack
my-awesome-library-2.1.0.tgz
```

## 主な機能

- 自動メタデータ抽出: `package.json`から自動的にメタデータを読み取ります。
- ワークスペースサポート: モノレポで動作し、親パッケージからメタデータを自動的に継承します。
- 柔軟な出力: 含めるメタデータとその順序を正確に指定できます。
- TypeScriptメタデータ生成: ソースコードで使用するメタデータ定数を含むTypeScriptファイルを自動生成出来ます。
- Gitメタデータ抽出: ローカルGitリポジトリからGitコミットハッシュ、タグ、ブランチ、バージョン情報を自動的に抽出します。
- pack/publish CLIインターフェースをサポート: この機能を使用して公開する際、`package.json`に上記の処理を適用した後にパッケージが生成されます。

---

## インストール

`devDependencies`にインストールして下さい。screw-upは実行時のコードを必要としません。

```bash
npm install --save-dev screw-up
```

## 使い方

以下に、構成方法を示します。
推奨される構成や運用方法を素早く知りたい場合は、「運用の推奨構成」の章を参照して下さい。

### Viteプラグインの準備

`vite.config.ts`にプラグインを追加します:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp(), // デフォルトの出力キーを使用
  ],
  // ...
});
```

`outputKeys`が指定されていない場合、デフォルトで以下のメタデータキーをこの順序で使用します:
`name`, `version`, `description`, `author`, `license`, `repository.url`, `git.commit.hash`.

### カスタム出力キー

含めるメタデータフィールドとその順序を指定できます:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      outputKeys: ['name', 'version', 'license'], // これらのフィールドのみを含める
    }),
  ],
  // ...
});
```

これにより、指定されたフィールドのみを含むバナーが生成されます:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * license: Apache-2.0
 */
```

### ネストされたオブジェクトの操作

プラグインはドット記法を使用することで、ネストされたオブジェクトを自動的にフラット化します。
以下のような`package.json`定義がある場合:

```json
{
  "name": "my-package",
  "author": {
    // ネストしたメタデータ
    "name": "Jane Developer",
    "email": "jane@example.com"
  },
  "repository": {
    // ネストしたメタデータ
    "type": "git",
    "url": "https://github.com/user/my-package"
  }
}
```

`outputKeys`でネストされたフィールドを参照できます:

```typescript
screwUp({
  outputKeys: ['name', 'author.name', 'author.email', 'repository.url'],
});
```

結果:

```javascript
/*!
 * name: my-package
 * author.name: Jane Developer
 * author.email: jane@example.com
 * repository.url: https://github.com/user/my-package
 */
```

### TypeScriptメタデータ生成

プラグインは、インポートして使用できるメタデータ定数を含む、TypeScriptファイルを生成できます:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      // メタデータファイル生成を有効化
      outputMetadataFile: true,
      // カスタムパス（オプション）
      outputMetadataFilePath: 'src/generated/packageMetadata.ts',
      // 含めるキー（オプション）
      outputMetadataKeys: [
        'name',
        'version',
        'description',
        'author',
        'license',
      ],
    }),
  ],
  // ...
});
```

これにより、TypeScript定数を含む`src/generated/packageMetadata.ts`が生成されます：

```typescript
// This file is auto-generated by screw-up plugin
// Do not edit manually

export const name = 'my-awesome-library';
export const version = '2.1.0';
export const description = 'An awesome TypeScript library';
export const author = 'Jane Developer <jane@example.com>';
export const license = 'Apache-2.0';
```

その後、これらの定数をソースコードでインポートして使用できます:

```typescript
import { name, version } from './generated/packageMetadata.js';

// Output: my-awesome-library v2.1.0
console.log(`${name} v${version}`);

export function getLibraryInfo() {
  return { name, version };
}
```

#### TypeScript型定義ファイル生成

TypeScriptソースファイルに加えて、より良いTypeScriptサポートのために対応する型定義ファイル（.d.ts）も生成されます。
`outputMetadataFilePath`の拡張子を`.d.ts`に変更したパスがデフォルトとして使用されます。
`outputMetadataFileTypePath`を指定することで、出力先のファイルを変更できます:

```typescript
screwUp({
  outputMetadataFile: true,
  // オプション: 型定義ファイルのカスタムパス
  outputMetadataFileTypePath: 'src/generated/packageMetadata.d.ts',
});
```

TypeScript型宣言は以下のようなコードです:

```typescript
// This file is auto-generated by screw-up plugin
// Do not edit manually

export declare const name: string;
export declare const version: string;
export declare const description: string;
export declare const author: string;
export declare const license: string;
```

注意: 型定義ファイルは、プラグイン動作の早い段階に生成されるため、実際にメタデータソースコード `packageMetadata.ts` が生成されるまでは、メタデータ項目が出力されているかどうかわからないことがあるため注意が必要です。例えば、最終的に存在しないメタデータ項目 `foobar` が `outputMetadataKeys` に指定されていると、`declare`宣言文は生成されますが、対応する`const foobar`変数は生成されないため、参照するとビルドエラーとなります。

#### キーのサニタイズ

特殊文字を含むキーは、有効なTypeScript識別子に自動的にサニタイズされます:

- `repository.url` → `repository_url`
- `custom-key` → `custom_key`
- `123invalid` → `_123invalid`

### Gitメタデータ

プラグインは、ローカルGitリポジトリからGitメタデータを自動的に抽出し、メタデータキーとして利用可能にします。

#### 利用可能なGitメタデータ

- `git.version`: Gitタグとコミット深さに基づいて、自動的に計算されたバージョン（後述）
- `git.commit.hash`: 現在のコミットの完全なコミットハッシュ
- `git.commit.short`: 短いコミットハッシュ（最初の7文字）
- `git.commit.date`: ISO形式のコミット日時
- `git.commit.message`: コミットメッセージ
- `git.tags`: 現在のコミットを指すすべてのタグの配列
- `git.branches`: 現在のコミットを含むブランチの配列

デフォルトで、`package.json`の`version`値は、自動的に`git.version`の値でオーバーライドされます。従って、NPMパッケージ生成時においても、Gitタグに基づいたバージョンを適用できます(CLIを使用します)。

#### バージョン計算

Gitバージョン計算は以下のアルゴリズムに従います:

1. タグ付きコミット: タグバージョンを直接使用（例: `v1.2.3` --> `1.2.3`）
2. タグなしコミット: 最も遠い祖先タグまでの深さを検出して、最後のバージョンコンポーネントをインクリメント
3. 変更されたワーキングディレクトリ: 未コミットの変更が存在する場合、バージョンを1つインクリメント
4. タグが見つからない場合: デフォルトで`0.0.1`とし、各コミットに対してインクリメント

Gitメタデータを含む例:

```typescript
screwUp({
  outputKeys: [
    'name',
    'version',
    'git.version',
    'git.commit.hash',
    'git.commit.short',
  ],
});
```

結果:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * git.version: 2.1.0
 * git.commit.hash: c94eaf71dcc6522aae593c7daf85bb745112caf0
 * git.commit.short: c94eaf7
 */
```

---

## 高度な使用方法

### モノレポサポート

プラグインは、ワークスペース設定を自動的に検出し、親パッケージからメタデータを継承します:

```
my-monorepo/
├── package.json          # 共有メタデータを持つルートパッケージ
├── packages/
│   ├── ui/
│   │   └── package.json  # 子パッケージ
│   └── core/
│       └── package.json  # 子パッケージ
```

子パッケージは、特定のフィールドをオーバーライドする機能を持ちながら、ルートパッケージからメタデータを自動的に継承します:

```json
// ルートのpackage.json
{
  "name": "my-monorepo",
  "version": "1.0.0",
  "author": "Company Team",
  "license": "MIT"
}

// packages/ui/package.json
{
  "name": "@my-monorepo/ui",
  "description": "UI components library"
}
```

UIパッケージをビルドすると、バナーには以下が含まれます:

```javascript
/*!
 * name: @my-monorepo/ui
 * version: 1.0.0
 * description: UI components library
 * author: Company Team
 * license: MIT
 */
```

## サポートされるワークスペースタイプ

プラグインは以下を自動的に検出してサポートします:

- npm/yarnワークスペース: `package.json`の`workspaces`フィールドで検出
- pnpmワークスペース: `pnpm-workspace.yaml`ファイルで検出
- Lerna: `lerna.json`ファイルで検出

---

## CLI使用方法

`screw-up`パッケージには、プロジェクトのパッケージ化と公開のためのコマンドラインインターフェースが含まれています。

### シンプルな例

```bash
# `package.json`がどのように解決されるのかをダンプ (JSON)
screw-up dump

# カスタムREADMEと限定継承でパック
screw-up pack --readme ./docs/DIST_README.md --inheritable-fields "version,license"

# カスタムpeerDependenciesプレフィックスでパック
screw-up pack --peer-deps-prefix "~"

# peerDependencies置き換えなしでパック
screw-up pack --no-replace-peer-deps

# ドライランでビルドして公開
screw-up publish --dry-run

# ベータチャンネルに公開
screw-up publish --tag beta

# スコープ付きパッケージをパブリックとして公開
screw-up publish --access public

# カスタムディレクトリにパックしてから公開
screw-up pack --pack-destination ./release
screw-up publish ./release/my-package-1.0.0.tgz
```

任意のコマンドのヘルプについて:

```bash
screw-up --help
screw-up dump --help
screw-up pack --help
screw-up publish --help
```

### packコマンド

プロジェクトのtarアーカイブを作成します:

```bash
# 現在のディレクトリをパック
screw-up pack

# 特定のディレクトリをパック
screw-up pack ./my-project

# 特定の出力ディレクトリにパック
screw-up pack --pack-destination ./dist
```

packコマンドの機能:

- メタデータのために`package.json`を自動的に読み取り
- ワークスペース継承をサポート（親パッケージからメタデータを継承）
- `{name}-{version}.tgz`形式で圧縮された`.tgz`アーカイブを作成

packコマンドは、内部で`npm pack`を使用して、仮のパッケージファイルを生成します。その後、パッケージファイルに対して`package.json`の置き換えやREADMEの変更などを行います。このように動作するため、`files`キーの取り扱いなども、`npm pack`で想定される仕様に完全に準拠します。

但し、パッキングを成功させるためには、必ず`version`キーを定義する必要があります。screw-up自身は、自動的に`version`キーに指定するバージョンを特定でき、その値を最終的なNPMパッケージファイルに反映します。しかし、`version`キーが存在しないと、最初の`npm pack`実行でエラーが発生します。これを避けるため、「運用の推奨構成」の例では、ダミーの`version`キーを指定しています。

#### オプション

- `--pack-destination <path>`: アーカイブの出力ディレクトリを指定
- `--readme <path>`: README.mdを指定したファイルで置換
- `--inheritable-fields <list>`: 親から継承するフィールドのコンマ区切りリスト（デフォルト: version,description,author,license,repository,keywords,homepage,bugs,readme）
- `--no-wds`: バージョンインクリメントのワーキングディレクトリステータスチェックを無効化
- `--no-replace-peer-deps`: peerDependenciesの"\*"を実際のバージョンに置き換える機能を無効化
- `--peer-deps-prefix <prefix>`: 置き換えられるpeerDependenciesのバージョンプレフィックス（デフォルト: "^"）

### publishコマンド

プロジェクトをレジストリサーバーに公開します:

```bash
# 現在のディレクトリを公開（アーカイブを作成して公開）
screw-up publish

# 特定のディレクトリを公開
screw-up publish ./my-project

# 既存のtarballを公開
screw-up publish package.tgz

# npmオプション付きで公開（すべてのnpm publishオプションがサポートされています）
screw-up publish --dry-run --tag beta --access public
```

publishコマンドの機能:

- すべての`npm publish`オプションを透過的にサポート。このコマンドは、アーカイブ生成を行った後、実際の発行処理を`npm publish`を呼び出すことで実行します。
- ディレクトリから公開（自動的にアーカイブを作成）または既存のtarballから公開可能
- 適切なメタデータ継承でワークスペースパッケージを処理
- packコマンドと同じパッケージ化ロジックを使用

#### オプション

- `--inheritable-fields <list>`: 親から継承するフィールドのコンマ区切りリスト
- `--no-wds`: バージョンインクリメントのワーキングディレクトリステータスチェックを無効化
- `--no-replace-peer-deps`: peerDependenciesの"\*"を実際のバージョンに置き換える機能を無効化
- `--peer-deps-prefix <prefix>`: 置き換えられるpeerDependenciesのバージョンプレフィックス（デフォルト: "^"）
- すべての`npm publish`オプションがサポートされています（例: `--dry-run`、`--tag`、`--access`、`--registry`）

### dumpコマンド

計算されたpackage.jsonをJSONとして出力します:

```bash
# 現在のディレクトリのpackage.jsonを出力
screw-up dump

# 特定のディレクトリのpackage.jsonを出力
screw-up dump ./my-project

# カスタム継承フィールドで出力
screw-up dump --inheritable-fields "author,license"
```

dumpコマンドの機能:

- すべての処理（ワークスペース継承、Gitメタデータなど）後の最終的な計算済み`package.json`を表示
- デバッグとパッケージメタデータの解決方法の理解に有用
- 他のツールにパイプできるクリーンなJSONを出力（`jq`など）

#### オプション

- `--inheritable-fields <list>`: 親から継承するフィールドのコンマ区切りリスト
- `--no-wds`: バージョンインクリメントのワーキングディレクトリステータスチェックを無効化

### README置換機能

packコマンドは複数の方法でREADME置換をサポートします:

#### CLIオプション経由

```bash
# README.mdをカスタムファイルで置換
screw-up pack --readme ./docs/README_package.md
```

#### package.jsonフィールド経由

```json
{
  "name": "my-package",
  "readme": "docs/PACKAGE_README.md"
}
```

両方が指定された場合、`--readme` CLIオプションが`package.json`フィールドより優先されます。

### peerDependencies置き換え機能

ワークスペース環境では、開発中のバージョン制約を避けるために`peerDependencies`で兄弟パッケージを"\*"で参照することが一般的です。パッケージ化時、screw-upは自動的にこれらのワイルドカードを実際のバージョン番号に置き換えます:

```json
{
  "name": "@workspace/cli",
  "peerDependencies": {
    "@workspace/core": "*"
  }
}
```

パッケージ化後、"\*"は実際のバージョンに置き換えられます:

```json
{
  "name": "@workspace/cli",
  "peerDependencies": {
    "@workspace/core": "^2.1.0"
  }
}
```

#### 機能の制御

```bash
# デフォルト動作（"^"プレフィックスを使用）
screw-up pack

# 機能を完全に無効化
screw-up pack --no-replace-peer-deps

# 異なるバージョンプレフィックスを使用
screw-up pack --peer-deps-prefix "~"
screw-up pack --peer-deps-prefix ">="

# 厳密なバージョン（プレフィックスなし）
screw-up pack --peer-deps-prefix ""
```

この機能の特徴：

- ワークスペース環境でのみ動作（`workspaces`フィールドを持つワークスペースルートが必要）
- ワークスペース兄弟パッケージ名と一致する"\*"値のみを置き換え
- 非ワークスペース依存関係は変更されません
- packおよびpublishコマンドでデフォルトで有効

### ワークスペースフィールド継承

モノレポで親パッケージから継承するメタデータフィールドを制御します:

```bash
# 特定のフィールドのみ継承
screw-up pack --inheritable-fields "version,author,license"

# 継承を完全に無効化
screw-up pack --inheritable-fields ""

# 公開時にカスタムフィールドを使用
screw-up publish --inheritable-fields "version,description,keywords"
```

デフォルト継承フィールド：`version`、`description`、`author`、`license`、`repository`、`keywords`、`homepage`、`bugs`、`readme`

---

## 運用の推奨構成

screw-upを使用すると、開発ライフサイクルをシンプルに保つことが出来ます。
以下に、シングルプロジェクトの場合とワークスペースによるモノレポの場合の、代表的な構成方法を示します。

### シングルプロジェクト構成

シングルプロジェクトでは、screw-upを最適に使用するために以下のような構成例を使用できます:

```
my-project/
├── package.json
├── README.md                     # 開発用README（GitHub/GitLabなどで表示）
├── README_pack.md                # 配布用README（オプション）
├── vite.config.ts                # screw-upプラグイン設定
├── src/
│   ├── index.ts
│   └── generated/
│       ├── packageMetadata.ts    # `outputMetadataFile`により自動生成
│       ├── packageMetadata.d.ts  # `outputMetadataFile`により自動生成
│       └── .gitignore            # `packageMetadata.ts`を除外(プラグインが自動生成)
└── dist/                         # メタデータバナー付きビルド出力
```

#### package.json構造

```json
{
  "name": "my-awesome-library",
  "version": "0.0.1",
  "description": "開発者向けの素晴らしいTypeScriptライブラリ",
  "author": "Jane Developer <jane@example.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/user/my-awesome-library"
  },
  "keywords": ["typescript", "library", "awesome"],
  "homepage": "https://github.com/user/my-awesome-library#readme",
  "bugs": {
    "url": "https://github.com/user/my-awesome-library/issues"
  },
  "readme": "README_pack.md",
  "files": ["dist/**/*"],
  "scripts": {
    "build": "vite build",
    "test": "npm run build && vitest run",
    "pack": "npm run build && screw-up pack --pack-destination artifacts/"
  }
}
```

重要なポイント:

- ダミーの`version`: バージョン指定(上記例では`0.0.1`)は使われず、screw-upにGitタグを通じてバージョン管理を行わせる
- メタデータフィールドを含める: `name`、`description`、`author`、`license`など
- `files`を指定: パッケージに含めるファイルを制御
- オプションの`readme`フィールド: 配布専用のREADMEファイルを指定。ここに指定するREADMEファイルは、`files`に含まれていなくても構いません。
- パッケージング: `scripts`に`pack`を加え、screw-upでパッケージングを実行できるようにする

#### Vite設定

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      // (必要であれば`packageMetadata.ts`を生成)
      outputMetadataFile: true,
    }),
  ],
  // ...
});
```

`outputMetadataFile`を`true`にすると、`packageMetadata.ts`と`packageMetadata.d.ts`が生成されるようになります。デフォルトでは`packageMetadata.ts`にGitコミットIDが含まれるため、コミット毎にファイルが更新されます。現在のscrew-upはメタデータファイルと同じディレクトリに`.gitignore`が存在しない場合、自動的に作成して除外設定を行います。ただし、生成先を変更した場合などは`.gitignore`が維持されていることを確認してください。

#### 開発環境セットアップ

```bash
# dev dependencyとしてインストール
npm install --save-dev screw-up
```

### ワークスペース構成（モノレポ）

モノレポセットアップでは、共有メタデータとプロジェクト固有メタデータを整理します：

```
my-monorepo/
├── package.json          # ルートメタデータ（versionなし）
├── README.md             # 開発用README（GitHub/GitLabで表示）
├── README_shared.md      # 共有README
├── core/
│   ├── package.json      # プロジェクト固有メタデータ（versionなし）
│   ├── vite.config.ts
│   └── src/
├── ui/
│   ├── package.json      # coreを"*"で参照（versionなし）
│   └── src/
└── cli/
    ├── package.json      # coreを"*"で参照（versionなし）
    └── src/
```

#### ルート package.json

```json
{
  "name": "my-monorepo",
  "description": "Monorepo containing multiple packages",
  "author": "Development Team <team@company.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/company/my-monorepo"
  },
  "homepage": "https://github.com/company/my-monorepo#readme",
  "bugs": {
    "url": "https://github.com/company/my-monorepo/issues"
  },
  "readme": "README_shared.md",
  "workspaces": ["core", "ui", "cli"],
  "private": true,
  "scripts": {
    "build": "npm run build --workspaces",
    "test": "npm run test --workspaces",
    "pack": "npm run pack --workspaces"
  }
}
```

`private` とマークしてパッキングを無視します。パッキングしないので、`version`キーも不要です。

#### サブプロジェクト package.json

```json
{
  "name": "@company/ui-components",
  "version": "0.0.1",
  "description": "Reusable UI components library",
  "keywords": ["ui", "components", "react"],
  "peerDependencies": {
    "@company/core": "*",
    "react": "^18.0.0"
  },
  "files": ["dist/**/*"],
  "scripts": {
    "build": "vite build",
    "test": "npm run build && vitest run",
    "pack": "npm run build && screw-up pack --pack-destination artifacts/"
  }
}
```

重要なポイント:

- ルートパッケージ: 共有メタデータ（`author`、`license`、`repository`など）を定義
- サブプロジェクト: プロジェクト固有の値（`name`、`description`、`keywords`）でオーバーライド
- 兄弟参照: peerで参照が必要な場合、ワークスペース兄弟に対して`peerDependencies`で`"*"`を使用
- ダミーの`version`: バージョン指定(上記例では`0.0.1`)は使われず、screw-upにGitタグを通じてバージョン管理を行わせる
- 共有README: ルートレベルで定義し、サブプロジェクトに継承可能
- `scripts`に`pack`を加え、screw-upでパッケージングを実行できるようにする

#### Vite設定

シングルプロジェクト構成と同様です。

#### 開発環境セットアップ

それぞれのサブプロジェクトでscrew-upをインストールします。

#### CLI使用例

```bash
# 個別サブプロジェクトをパック
screw-up pack packages/ui-components

# カスタム継承でパック
screw-up pack packages/cli --inheritable-fields "author,license,repository"

# peerDependencies置き換えなしでパック
screw-up pack packages/plugin --no-replace-peer-deps

# カスタムプレフィックスで公開
screw-up publish packages/core --peer-deps-prefix "~"
```

---

## 補足

このプロジェクトは [RelaxVersioner](https://github.com/kekyo/RelaxVersioner/) の後継として開発されました。RelaxVersionerは.NETプラットフォーム向けで、NPMサポートオプションを追加しました。しかし、Gitタグとの親和性があまり良くないため、Viteプラグインを使用することを前提として、最も望ましい運用を想定して仕様を検討しました。

screw-upのGitタグからバージョン番号を計算するアルゴリズムは、完全にRelaxVersionerと同一です。つまり、あなたがASP.NET Coreでサーバーのコードを保守している場合、.NETとのバージョンを完全に統一して扱うことができます。

## ライセンス

Under MIT
