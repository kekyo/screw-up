# screw-up

NPM向けの、シンプルなパッケージメタデータ挿入ツール

![screw-up](images/screw-up-120.png)

[![Project Status: WIP – Initial development is in progress, but there has not yet been a stable, usable release suitable for the public.](https://www.repostatus.org/badges/latest/wip.svg)](https://www.repostatus.org/#wip)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![npm version](https://img.shields.io/npm/v/screw-up.svg)](https://www.npmjs.com/package/screw-up)

----

[In English](./README.md)

## これは何ですか？

バージョンをTypeScriptプロジェクトやNPMパッケージに適用する、シンプルなソリューションを探していますか？
`screw-up` はあたなが必要とするツールになり得ます。

これは、パッケージメタデータ（名前、バージョン、説明、作者、ライセンスなど）を含むバナーコメントをバンドルされたファイルに自動的に挿入するViteプラグインと、NPMパッケージに適用するCLIツールです。

Viteプラグインは、自動的に`package.json`からメタデータを読み取ります:

```json
{
  "name": "my-awesome-library",
  "version": "2.1.0",
  "description": "An awesome TypeScript library",
  "author": "Jane Developer <jane@example.com>",
  "license": "Apache-2.0",
  "repository": {
    "url": "https://github.com/user/my-awesome-library"
  }
}
```

各バンドルされたソースファイル（`dist/index.js`など）にバナーヘッダーを挿入します：

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * description: An awesome TypeScript library
 * author: Jane Developer <jane@example.com>
 * license: Apache-2.0
 * repository.url: https://github.com/user/my-awesome-library
 * git.commit.hash: c94eaf71dcc6522aae593c7daf85bb745112caf0
 */
// Your bundled code here...
```

`git.commit.hash:`という行に気がついたかもしれません。そうです、プロジェクトがGitで管理されている場合（管理していますよね？）、そのコミットIDやブランチ・タグの情報を挿入させることもできます。
そして最も重要なのは、Gitタグにバージョンが適用されている場合、そのバージョンタグを自動的に `package.json` の `version` に反映させることができます。つまり、Gitタグだけを使って、バージョン番号の管理ができます!

`npm pack` ではなく、CLIツール `screw-up` を使ってパッケージを生成すれば、収集されたメタデータをNPMパッケージの `package.json` に自動で適用できます:

```bash
# `screw-up`コマンドを使ってパッケージを生成
$ screw-up pack
my-awesome-library-2.1.0.tgz
```

## 主な機能

* 自動メタデータ抽出: `package.json`から自動的にメタデータを読み取ります。
* ワークスペースサポート: モノレポで動作し、親パッケージからメタデータを自動的に継承します。
* 柔軟な出力: 含めるキーとその順序を正確に指定できます。
* ネストされたオブジェクトサポート: `author.name`、`repository.url`などのネストされたオブジェクトを処理します。
* カスタマイズ可能: バナーに含めるメタデータフィールドを選択できます。
* TypeScriptメタデータ生成: ソースコードで使用するメタデータ定数を含むTypeScriptファイルを自動生成出来ます。
* Gitメタデータ抽出: ローカルGitリポジトリからGitコミットハッシュ、タグ、ブランチ、バージョン情報を自動的に抽出します。
* pack/publish CLIインターフェースをサポート: この機能を使用して公開する際、`package.json`に上記の処理を適用した後にパッケージが生成されます。

----

## インストール

`devDependencies`にインストールして下さい。screw-upは実行時のコードを必要としません。

```bash
npm install --save-dev screw-up
```

## 使い方

以下に、構成方法を示します。
推奨される構成や運用方法を素早く知りたい場合は、「運用の推奨構成」の章を参照して下さい。

### Viteプラグインの準備

`vite.config.ts`にプラグインを追加します:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp()  // デフォルトの出力キーを使用
  ],
  // ...
});
```

`outputKeys`が指定されていない場合、デフォルトで以下のメタデータキーをこの順序で使用します:
`name`, `version`, `description`, `author`, `license`, `repository.url`, `git.commit.hash`.

### カスタム出力キー

含めるメタデータフィールドとその順序を指定できます:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      outputKeys: ['name', 'version', 'license']  // これらのフィールドのみを含める
    })
  ],
  // ...
});
```

これにより、指定されたフィールドのみを含むバナーが生成されます:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * license: Apache-2.0
 */
```

### ネストされたオブジェクトの操作

プラグインはドット記法を使用することで、ネストされたオブジェクトを自動的にフラット化します。
以下のような`package.json`定義がある場合:

```json
{
  "name": "my-package",
  "author": {   // ネストしたメタデータ
    "name": "Jane Developer",
    "email": "jane@example.com"
  },
  "repository": {   // ネストしたメタデータ
    "type": "git",
    "url": "https://github.com/user/my-package"
  }
}
```

`outputKeys`でネストされたフィールドを参照できます:

```typescript
screwUp({
  outputKeys: ['name', 'author.name', 'author.email', 'repository.url']
})
```

結果:

```javascript
/*!
 * name: my-package
 * author.name: Jane Developer
 * author.email: jane@example.com
 * repository.url: https://github.com/user/my-package
 */
```

### TypeScriptメタデータ生成

プラグインは、インポートして使用できるメタデータ定数を含む、TypeScriptファイルを生成できます:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      // メタデータファイル生成を有効化
      outputMetadataFile: true,
      // カスタムパス（オプション）
      outputMetadataFilePath: 'src/generated/packageMetadata.ts',
      // 含めるキー（オプション）
      outputMetadataKeys: ['name', 'version', 'description', 'author', 'license']
    })
  ],
  // ...
});
```

これにより、TypeScript定数を含む`src/generated/packageMetadata.ts`が生成されます：

```typescript
// This file is auto-generated by screw-up plugin
// Do not edit manually

export const name = "my-awesome-library";
export const version = "2.1.0";
export const description = "An awesome TypeScript library";
export const author = "Jane Developer <jane@example.com>";
export const license = "Apache-2.0";
```

その後、これらの定数をソースコードでインポートして使用できます:

```typescript
import { name, version } from './generated/packageMetadata.js';

// Output: my-awesome-library v2.1.0
console.log(`${name} v${version}`);

export function getLibraryInfo() {
  return { name, version };
}
```

#### キーのサニタイズ

特殊文字を含むキーは、有効なTypeScript識別子に自動的にサニタイズされます:

- `repository.url` → `repository_url`
- `custom-key` → `custom_key`
- `123invalid` → `_123invalid`

### Gitメタデータ

プラグインは、ローカルGitリポジトリからGitメタデータを自動的に抽出し、メタデータキーとして利用可能にします。

#### 利用可能なGitメタデータ

- `git.version`: Gitタグとコミット深さに基づいて、自動的に計算されたバージョン
- `git.commit.hash`: 現在のコミットの完全なコミットハッシュ
- `git.commit.short`: 短いコミットハッシュ（最初の7文字）
- `git.commit.date`: ISO形式のコミット日時
- `git.commit.message`: コミットメッセージ
- `git.tags`: 現在のコミットを指すすべてのタグの配列
- `git.branches`: 現在のコミットを含むブランチの配列

#### バージョン計算

Gitバージョン計算は以下のアルゴリズムに従います:

1. タグ付きコミット: タグバージョンを直接使用（例: `v1.2.3` --> `1.2.3`）
2. タグなしコミット: 最も遠い祖先タグまでの深さを検出して、最後のバージョンコンポーネントをインクリメント
3. 変更されたワーキングディレクトリ: 未コミットの変更が存在する場合、バージョンを1つインクリメント
4. タグが見つからない場合: デフォルトで`0.0.1`とし、各コミットに対してインクリメント

更に、この計算結果は `package.json` の `version` キーのデフォルト値として適用されます。
従って、 `package.json` に `version` キーを含めずに、Gitタグとscrew-upを使用してバージョン番号の管理を行うことが出来ます。

Gitメタデータを含む例:

```typescript
screwUp({
  outputKeys: ['name', 'version', 'git.version', 'git.commit.hash', 'git.commit.short']
})
```

結果:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * git.version: 1.2.4
 * git.commit.hash: c94eaf71dcc6522aae593c7daf85bb745112caf0
 * git.commit.short: c94eaf7
 */
```

----

## 高度な使用方法

### モノレポサポート

プラグインは、ワークスペース設定を自動的に検出し、親パッケージからメタデータを継承します:

```
my-monorepo/
├── package.json          # 共有メタデータを持つルートパッケージ
├── packages/
│   ├── ui/
│   │   └── package.json  # 子パッケージ
│   └── core/
│       └── package.json  # 子パッケージ
```

子パッケージは、特定のフィールドをオーバーライドする機能を持ちながら、ルートパッケージからメタデータを自動的に継承します:

```json
// ルートのpackage.json
{
  "name": "my-monorepo",
  "version": "1.0.0",
  "author": "Company Team",
  "license": "MIT"
}

// packages/ui/package.json
{
  "name": "@my-monorepo/ui",
  "description": "UI components library"
}
```

UIパッケージをビルドすると、バナーには以下が含まれます:

```javascript
/*!
 * name: @my-monorepo/ui
 * version: 1.0.0
 * description: UI components library
 * author: Company Team
 * license: MIT
 */
```

## サポートされるワークスペースタイプ

プラグインは以下を自動的に検出してサポートします:

- npm/yarnワークスペース: `package.json`の`workspaces`フィールドで検出
- pnpmワークスペース: `pnpm-workspace.yaml`ファイルで検出
- Lerna: `lerna.json`ファイルで検出

----

## CLI使用方法

`screw-up`パッケージには、プロジェクトのパッケージ化と公開のためのコマンドラインインターフェースが含まれています。

### シンプルな例

```bash
# パッケージ解決をデバッグ
screw-up dump --inheritable-fields "version,author"

# カスタムREADMEと限定継承でパック
screw-up pack --readme ./docs/DIST_README.md --inheritable-fields "version,license"

# カスタムpeerDependenciesプレフィックスでパック
screw-up pack --peer-deps-prefix "~"

# peerDependencies置き換えなしでパック
screw-up pack --no-replace-peer-deps

# ドライランでビルドして公開
screw-up publish --dry-run

# ベータチャンネルに公開
screw-up publish --tag beta

# スコープ付きパッケージをパブリックとして公開
screw-up publish --access public

# カスタムディレクトリにパックしてから公開
screw-up pack --pack-destination ./release
screw-up publish ./release/my-package-1.0.0.tgz
```

任意のコマンドのヘルプについて:

```bash
screw-up --help
screw-up dump --help
screw-up pack --help
screw-up publish --help
```

### packコマンド

プロジェクトのtarアーカイブを作成します:

```bash
# 現在のディレクトリをパック
screw-up pack

# 特定のディレクトリをパック
screw-up pack ./my-project

# 特定の出力ディレクトリにパック
screw-up pack --pack-destination ./dist
```

packコマンドの機能:

- メタデータとファイル包含ルールのために`package.json`を自動的に読み取り
- `package.json`の`files`フィールドを尊重
- ワークスペース継承をサポート（親パッケージからメタデータを継承）
- `{name}-{version}.tgz`形式で圧縮された`.tgz`アーカイブを作成

#### オプション

- `--pack-destination <path>`: アーカイブの出力ディレクトリを指定
- `--readme <path>`: README.mdを指定したファイルで置換
- `--inheritable-fields <list>`: 親から継承するフィールドのコンマ区切りリスト（デフォルト: version,description,author,license,repository,keywords,homepage,bugs,readme）
- `--no-wds`: バージョンインクリメントのワーキングディレクトリステータスチェックを無効化
- `--no-replace-peer-deps`: peerDependenciesの"*"を実際のバージョンに置き換える機能を無効化
- `--peer-deps-prefix <prefix>`: 置き換えられるpeerDependenciesのバージョンプレフィックス（デフォルト: "^"）

### publishコマンド

プロジェクトをレジストリサーバーに公開します:

```bash
# 現在のディレクトリを公開（アーカイブを作成して公開）
screw-up publish

# 特定のディレクトリを公開
screw-up publish ./my-project

# 既存のtarballを公開
screw-up publish package.tgz

# npmオプション付きで公開（すべてのnpm publishオプションがサポートされています）
screw-up publish --dry-run --tag beta --access public
```

publishコマンドの機能:

- すべての`npm publish`オプションを透過的にサポート。このコマンドは、アーカイブ生成を行った後、実際の発行処理を`npm publish`を呼び出すことで実行します。
- ディレクトリから公開（自動的にアーカイブを作成）または既存のtarballから公開可能
- 適切なメタデータ継承でワークスペースパッケージを処理
- packコマンドと同じパッケージ化ロジックを使用

#### オプション

- `--inheritable-fields <list>`: 親から継承するフィールドのコンマ区切りリスト
- `--no-wds`: バージョンインクリメントのワーキングディレクトリステータスチェックを無効化
- `--no-replace-peer-deps`: peerDependenciesの"*"を実際のバージョンに置き換える機能を無効化
- `--peer-deps-prefix <prefix>`: 置き換えられるpeerDependenciesのバージョンプレフィックス（デフォルト: "^"）
- すべての`npm publish`オプションがサポートされています（例: `--dry-run`、`--tag`、`--access`、`--registry`）

### dumpコマンド

計算されたpackage.jsonをJSONとして出力します:

```bash
# 現在のディレクトリのpackage.jsonを出力
screw-up dump

# 特定のディレクトリのpackage.jsonを出力
screw-up dump ./my-project

# カスタム継承フィールドで出力
screw-up dump --inheritable-fields "author,license"
```

dumpコマンドの機能:

- すべての処理（ワークスペース継承、Gitメタデータなど）後の最終的な計算済み`package.json`を表示
- デバッグとパッケージメタデータの解決方法の理解に有用
- 他のツールにパイプできるクリーンなJSONを出力

#### オプション

- `--inheritable-fields <list>`: 親から継承するフィールドのコンマ区切りリスト
- `--no-wds`: バージョンインクリメントのワーキングディレクトリステータスチェックを無効化

### README置換

packコマンドは複数の方法でREADME置換をサポートします:

#### CLIオプション経由

```bash
# README.mdをカスタムファイルで置換
screw-up pack --readme ./docs/README_package.md
```

#### package.jsonフィールド経由

```json
{
  "name": "my-package",
  "readme": "docs/PACKAGE_README.md"
}
```

両方が指定された場合、`--readme` CLIオプションが`package.json`フィールドより優先されます。

### peerDependencies置き換え

ワークスペース環境では、開発中のバージョン制約を避けるために`peerDependencies`で兄弟パッケージを"*"で参照することが一般的です。パッケージ化時、screw-upは自動的にこれらのワイルドカードを実際のバージョン番号に置き換えます：

```json
{
  "name": "@workspace/cli",
  "peerDependencies": {
    "@workspace/core": "*"
  }
}
```

パッケージ化後、"*"は実際のバージョンに置き換えられます：

```json
{
  "name": "@workspace/cli", 
  "peerDependencies": {
    "@workspace/core": "^2.1.0"
  }
}
```

#### 機能の制御

```bash
# デフォルト動作（"^"プレフィックスを使用）
screw-up pack

# 機能を完全に無効化
screw-up pack --no-replace-peer-deps

# 異なるバージョンプレフィックスを使用
screw-up pack --peer-deps-prefix "~"
screw-up pack --peer-deps-prefix ">="

# 厳密なバージョン（プレフィックスなし）
screw-up pack --peer-deps-prefix ""
```

この機能の特徴：
- ワークスペース環境でのみ動作（`workspaces`フィールドを持つワークスペースルートが必要）
- ワークスペース兄弟パッケージ名と一致する"*"値のみを置き換え
- 非ワークスペース依存関係は変更されません
- packおよびpublishコマンドでデフォルトで有効

### ワークスペースフィールド継承

モノレポで親パッケージから継承するメタデータフィールドを制御します:

```bash
# 特定のフィールドのみ継承
screw-up pack --inheritable-fields "version,author,license"

# 継承を完全に無効化
screw-up pack --inheritable-fields ""

# 公開時にカスタムフィールドを使用
screw-up publish --inheritable-fields "version,description,keywords"
```

デフォルト継承フィールド：`version`、`description`、`author`、`license`、`repository`、`keywords`、`homepage`、`bugs`、`readme`

----

## 運用の推奨構成

screw-upを使用すると、開発ライフサイクルをシンプルに保つことが出来ます。
以下に、シングルプロジェクトの場合とワークスペースによるモノレポの場合の、代表的な構成方法を示します。

### シングルプロジェクト構成

スタンドアロンプロジェクトでは、screw-upを最適に使用するために以下ののような構成例を使用できます:

```
my-project/
├── package.json                # versionフィールドなし
├── README.md                   # 開発用README（GitHub/GitLabなどで表示）
├── README_pack.md              # 配布用README（オプション）
├── vite.config.ts              # screw-upプラグイン設定
├── src/
│   ├── index.ts
│   └── generated/
│       └── packageMetadata.ts  # `outputMetadataFile`により自動生成
└── dist/                       # メタデータバナー付きビルド出力
```

#### package.json構造

```json
{
  "name": "my-awesome-library",
  "description": "開発者向けの素晴らしいTypeScriptライブラリ",
  "author": "Jane Developer <jane@example.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/user/my-awesome-library"
  },
  "keywords": ["typescript", "library", "awesome"],
  "homepage": "https://github.com/user/my-awesome-library#readme",
  "bugs": {
    "url": "https://github.com/user/my-awesome-library/issues"
  },
  "readme": "README_pack.md",
  "files": ["dist/**/*", "README_pack.md"],
  "scripts": {
    "build": "vite build",
    "test": "npm run build && vitest run",
    "pack": "npm run build && screw-up pack --pack-destination artifacts/"
  }
}
```

重要なポイント:

- `version`を削除: screw-upにGitタグを通じてバージョン管理を任せる
- メタデータフィールドを含める: `name`、`description`、`author`、`license`など
- オプションの`readme`フィールド: 配布専用のREADMEファイルを指定
- `files`を指定: パッケージに含めるファイルを制御
- パッケージング: `scripts`に`pack`を加え、screw-upでパッケージングを実行できるようにする

#### Vite設定

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      // (必要であれば`packageMetadata.ts`を生成)
      outputMetadataFile: true
    })
  ],
  // ...
});
```

#### 開発環境セットアップ

```bash
# dev dependencyとしてインストール
npm install --save-dev screw-up

# 配布用README作成（オプション）
echo "# 配布パッケージ" > README_pack.md
```

### ワークスペース構成（モノレポ）

モノレポセットアップでは、共有メタデータとプロジェクト固有メタデータを整理します：

```
my-monorepo/
├── package.json          # ルートメタデータ（versionなし）
├── README.md             # 開発用README（GitHub/GitLabで表示）
├── README_shared.md      # 共有README
├── core/
│   ├── package.json      # プロジェクト固有メタデータ（versionなし）
│   ├── vite.config.ts
│   └── src/
├── ui/
│   ├── package.json      # coreを"*"で参照（versionなし）
│   └── src/
└── cli/
    ├── package.json      # coreを"*"で参照（versionなし）
    └── src/
```

#### ルート package.json

```json
{
  "name": "my-monorepo",
  "description": "複数のパッケージを含むモノレポ",
  "author": "開発チーム <team@company.com>",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/company/my-monorepo"
  },
  "homepage": "https://github.com/company/my-monorepo#readme",
  "bugs": {
    "url": "https://github.com/company/my-monorepo/issues"
  },
  "readme": "README_shared.md",
  "workspaces": ["core", "ui", "cli"],
  "private": true,
  "scripts": {
    "build": "npm run build --workspaces",
    "test": "npm run test --workspaces",
    "pack": "npm run pack --workspaces"
  }
}
```

#### サブプロジェクト package.json

```json
{
  "name": "@company/ui-components",
  "description": "再利用可能なUIコンポーネントライブラリ",
  "keywords": ["ui", "components", "react"],
  "peerDependencies": {
    "@company/core": "*",
    "react": "^18.0.0"
  },
  "files": ["dist/**/*"],
  "scripts": {
    "build": "vite build",
    "test": "npm run build && vitest run",
    "pack": "npm run build && screw-up pack --pack-destination artifacts/"
  }
}
```

重要なポイント:

- ルートパッケージ: 共有メタデータ（`author`、`license`、`repository`など）を定義
- サブプロジェクト: プロジェクト固有の値（`name`、`description`、`keywords`）でオーバーライド
- 兄弟参照: peerで参照が必要な場合、ワークスペース兄弟に対して`peerDependencies`で`"*"`を使用
- バージョンなし: すべてのpackage.jsonファイルから`version`を削除
- 共有README: ルートレベルで定義し、サブプロジェクトに継承可能
- `scripts`に`pack`を加え、screw-upでパッケージングを実行できるようにする

#### Vite設定

シングルプロジェクト構成と同様。

#### 開発環境セットアップ

それぞれのサブプロジェクトでscrew-upをインストールします。

#### CLI使用例

```bash
# 個別サブプロジェクトをパック
screw-up pack packages/ui-components

# カスタム継承でパック
screw-up pack packages/cli --inheritable-fields "author,license,repository"

# peerDependencies置き換えなしでパック
screw-up pack packages/plugin --no-replace-peer-deps

# カスタムプレフィックスで公開
screw-up publish packages/core --peer-deps-prefix "~"
```

----

## 補足

このプロジェクトは [RelaxVersioner](https://github.com/kekyo/RelaxVersioner/) の後継として開発されました。RelaxVersionerは.NETプラットフォーム向けで、NPMサポートオプションを追加しました。しかし、Gitタグとの親和性があまり良くないため、Viteプラグインを使用することを前提として、最も望ましい運用を想定して仕様を検討しました。

screw-upのGitタグからバージョン番号を計算するアルゴリズムは、完全にRelaxVersionerと同一です。つまり、あなたがASP.NET Coreでサーバーのコードを保守している場合、.NETとのバージョンを完全に統一して扱うことができます。

## ライセンス

Under MIT
