# Screw-UP

Simply package metadata inserter for Vite plugins.

[![Project Status: WIP – Initial development is in progress, but there has not yet been a stable, usable release suitable for the public.](https://www.repostatus.org/badges/latest/wip.svg)](https://www.repostatus.org/#wip)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![npm version](https://img.shields.io/npm/v/screw-up.svg)](https://www.npmjs.com/package/screw-up)

----

## What is this?

This is a Vite plugin that automatically inserts banner comments containing package metadata (name, version, description, author, license, etc.) into your bundled files.

This will automatically read metadata from your `package.json`:

```json
{
  "name": "my-awesome-library",
  "version": "2.1.0",
  "description": "An awesome TypeScript library",
  "author": "Jane Developer <jane@example.com>",
  "license": "Apache-2.0",
  "repository": {
    "url": "https://github.com/user/my-awesome-library"
  }
}
```

To insert banner header each bundled source files (`dist/index.js` and etc.):

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * description: An awesome TypeScript library
 * author: Jane Developer <jane@example.com>
 * license: Apache-2.0
 * repository.url: https://github.com/user/my-awesome-library
 */
// Your bundled code here...
```

## Key Features

* Automatic metadata extraction: Reads metadata from `package.json` automatically.
* Workspace support: Works with monorepos and automatically inherits metadata from parent packages.
* Flexible output: Specify exactly which keys to include and in what order.
* Nested object support: Handles nested objects like `author.name`, `repository.url`.
* Customizable: Choose which metadata fields to include in your banner.
* TypeScript metadata generation: Automatically generates TypeScript files with metadata constants for use in your source code.
* Supported pack/publish CLI interface. When publishing using this feature, the package is generated after applying the above processing to `package.json`.

## Installation

```bash
npm install --save-dev screw-up
```

----

## Usage

### Basic Usage

Add the plugin to your `vite.config.ts`:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp()  // Uses default output keys
  ],
  build: {
    lib: {
      entry: 'src/index.ts',
      name: 'MyLibrary',
      fileName: 'index'
    }
  }
});
```

When no `outputKeys` are specified, the plugin uses these default keys with exact sequence:
`name`, `version`, `description`, `author`, `license` and `repository.url`.

### Custom Output Keys

You can specify which metadata fields to include and in what order:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      outputKeys: ['name', 'version', 'license']  // Only include these fields
    })
  ],
  build: {
    lib: {
      entry: 'src/index.ts',
      name: 'MyLibrary',
      fileName: 'index'
    }
  }
});
```

This will generate a banner with only the specified fields:

```javascript
/*!
 * name: my-awesome-library
 * version: 2.1.0
 * license: Apache-2.0
 */
```

### Working with Nested Objects

The plugin automatically flattens nested objects using dot notation:

```json
{
  "name": "my-package",
  "author": {
    "name": "Jane Developer",
    "email": "jane@example.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/user/my-package"
  }
}
```

You can reference nested fields in your `outputKeys`:

```typescript
screwUp({
  outputKeys: ['name', 'author.name', 'author.email', 'repository.url']
})
```

Results in:

```javascript
/*!
 * name: my-package
 * author.name: Jane Developer
 * author.email: jane@example.com
 * repository.url: https://github.com/user/my-package
 */
```

### TypeScript Metadata Generation

The plugin can generate TypeScript files containing metadata constants that you can import and use in your source code:

```typescript
import { defineConfig } from 'vite';
import screwUp from 'screw-up';

export default defineConfig({
  plugins: [
    screwUp({
      outputMetadataFile: true, // Enable metadata file generation
      outputMetadataFilePath: 'src/generated/packageMetadata.ts', // Custom path (optional)
      outputMetadataKeys: ['name', 'version', 'description', 'author', 'license'] // Keys to include
    })
  ],
  build: {
    lib: {
      entry: 'src/index.ts',
      name: 'MyLibrary',
      fileName: 'index'
    }
  }
});
```

This generates `src/generated/packageMetadata.ts` with sanitized TypeScript constants:

```typescript
// This file is auto-generated by screw-up plugin
// Do not edit manually

export const name = "my-awesome-library";
export const version = "2.1.0";
export const description = "An awesome TypeScript library";
export const author = "Jane Developer <jane@example.com>";
export const license = "Apache-2.0";
```

You can then import and use these constants in your source code:

```typescript
import { name, version } from './generated/packageMetadata.js';

console.log(`${name} v${version}`);
// Output: my-awesome-library v2.1.0

export function getLibraryInfo() {
  return { name, version };
}
```

#### Key Sanitization

Keys with special characters are automatically sanitized to valid TypeScript identifiers:

- `repository.url` → `repository_url`
- `custom-key` → `custom_key`
- `123invalid` → `_123invalid`

----

## Advanced Usage

### Monorepo Support

The plugin automatically detects workspace configurations and inherits metadata from parent packages:

```
my-monorepo/
├── package.json          # Root package with shared metadata
├── packages/
│   ├── ui/
│   │   └── package.json  # Child package
│   └── core/
│       └── package.json  # Child package
```

Child packages automatically inherit metadata from the root package, with the ability to override specific fields:

```json
// Root package.json
{
  "name": "my-monorepo",
  "version": "1.0.0",
  "author": "Company Team",
  "license": "MIT"
}

// packages/ui/package.json
{
  "name": "@my-monorepo/ui",
  "description": "UI components library"
}
```

When building the UI package, the banner will include:

```javascript
/*!
 * name: @my-monorepo/ui
 * version: 1.0.0
 * description: UI components library
 * author: Company Team
 * license: MIT
 */
```

### Programmatic Usage

You can also use the utility functions directly:

```typescript
import { generateBanner, readPackageMetadata } from 'screw-up/internal';

// Read package metadata
const metadata = await readPackageMetadata('./package.json');

// Generate banner with custom keys
const banner = generateBanner(metadata, ['name', 'version', 'license']);

console.log(banner);
// /*!
//  * name: my-package
//  * version: 1.0.0
//  * license: MIT
//  */
```

## Supported Workspace Types

The plugin automatically detects and supports:

- npm/yarn workspaces: Detected via `workspaces` field in `package.json`
- pnpm workspaces: Detected via `pnpm-workspace.yaml` file
- Lerna: Detected via `lerna.json` file

----

## CLI Usage

The `screw-up` package includes a command-line interface for packaging and publishing your projects.

### Pack Command

Create a tar archive of your project:

```bash
# Pack current directory
screw-up pack

# Pack specific directory
screw-up pack ./my-project

# Pack to specific output directory
screw-up pack --pack-destination ./dist
```

The pack command:

- Automatically reads `package.json` for metadata and file inclusion rules
- Respects the `files` field in your `package.json`
- Supports workspace inheritance (inherits metadata from parent packages)
- Creates a compressed `.tgz` archive with format: `{name}-{version}.tgz`

### Publish Command

Publish your project to registry server:

```bash
# Publish current directory (creates archive and publishes)
screw-up publish

# Publish specific directory
screw-up publish ./my-project

# Publish existing tarball
screw-up publish package.tgz

# Publish with npm options (all npm publish options are supported)
screw-up publish --dry-run --tag beta --access public
```

The publish command:

- Supports all `npm publish` options transparently
- Can publish from directory (automatically creates archive) or existing tarball
- Handles workspace packages with proper metadata inheritance
- Uses the same packaging logic as the pack command

### Examples

```bash
# Build and publish with dry run
screw-up publish --dry-run

# Publish to beta channel
screw-up publish --tag beta

# Publish scoped package as public
screw-up publish --access public

# Pack to custom directory then publish
screw-up pack --pack-destination ./release
screw-up publish ./release/my-package-1.0.0.tgz
```

For help with any command:

```bash
screw-up --help
screw-up pack --help
screw-up publish --help
```

----

## License

Under MIT
