// screw-up - Easy package metadata inserter on Vite plugin
// Copyright (c) Kouji Matsui (@kekyo@mi.kekyo.net)
// Under MIT.
// https://github.com/kekyo/screw-up/

import type { Plugin } from 'vite';
import { readFile, writeFile, readdir, mkdir } from 'fs/promises';
import { join, dirname } from 'path';
import { resolvePackageMetadata, createConsoleLogger } from './internal';
import { ScrewUpOptions, PackageMetadata } from './types';
import { getFetchGitMetadata } from './analyzer';

/**
 * Generate banner string from package.json metadata
 * @param metadata - Package metadata
 * @param outputKeys - Array of keys to output in specified order
 * @returns Banner string
 */
export const generateBanner = (metadata: PackageMetadata, outputKeys: string[]): string => {
  const parts: string[] = [];
  
  for (const key of outputKeys) {
    const value = metadata[key];
    if (value) {
      parts.push(`${key}: ${value}`);
    }
  }
  
  return parts.length > 0 ? `/*!\n * ${parts.join('\n * ')}\n */` : '';
};

/**
 * Insert banner header at appropriate position considering shebang
 * @param content - The content to insert banner into
 * @param banner - The banner header to insert
 * @returns Content with banner header inserted
 */
const insertBannerHeader = (content: string, banner: string): string => {
  const lines = content.split('\n');
  
  // Check if first line is shebang
  if (lines.length > 0 && lines[0].startsWith('#!')) {
    // Insert banner after shebang line
    return lines[0] + '\n' + banner + '\n' + lines.slice(1).join('\n');
  } else {
    // Insert banner at the beginning
    return banner + '\n' + content;
  }
};

/**
 * Convert string key to valid TypeScript identifier
 * @param key - The key to convert
 * @returns Valid TypeScript identifier
 */
const sanitizeKey = (key: string): string => {
  // Replace dots and other invalid characters with underscores
  return key.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^(\d)/, '_$1');
};

/**
 * Generate TypeScript metadata file content from package metadata
 * @param metadata - Package metadata
 * @param outputKeys - Array of keys to output
 * @returns TypeScript file content
 */
const generateMetadataFile = (metadata: PackageMetadata, outputKeys: string[]): string => {
  const lines: string[] = [];
  
  lines.push('// This file is auto-generated by screw-up plugin');
  lines.push('// Do not edit manually');
  lines.push('');
  
  for (const key of outputKeys) {
    const value = metadata[key];
    if (value) {
      const sanitizedKey = sanitizeKey(key);
      const escapedValue = JSON.stringify(value);
      lines.push(`export const ${sanitizedKey} = ${escapedValue};`);
    }
  }
  
  lines.push('');
  
  return lines.join('\n');
};

/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Vite plugin that adds banner to the bundled code
 * @param options - Plugin options
 * @returns Vite plugin
 */
export const screwUp = (options: ScrewUpOptions = {}): Plugin => {
  const {
    outputKeys = ['name', 'version', 'description', 'author', 'license', 'repository.url', 'git.commit.hash'],
    assetFilters = ['\\.d\\.ts$'],
    outputMetadataFile = false,
    outputMetadataFilePath = 'src/generated/packageMetadata.ts',
    outputMetadataKeys = ['name', 'version', 'description', 'author', 'license', 'repository.url', 'git.commit.hash'],
    checkWorkingDirectoryStatus = true,
    alwaysOverrideVersionFromGit = true,
    insertMetadataBanner = true} = options;

  const assetFiltersRegex = assetFilters.map(filter => new RegExp(filter));

  let logger = createConsoleLogger();
  let banner: string;
  let metadata: any;
  let projectRoot: string;
  let fetchGitMetadata = () => Promise.resolve<any>({});

  // Generate and write metadata TypeScript file
  const generateMetadataSourceFile = async () => {
    // Resolve package metadata
    const result = await resolvePackageMetadata(
      projectRoot, fetchGitMetadata, alwaysOverrideVersionFromGit, logger);
    metadata = result.metadata;
    // Regenerate banner with updated metadata
    banner = generateBanner(metadata, outputKeys);
    if (outputMetadataFile) {
      const metadataSourceContent = generateMetadataFile(metadata, outputMetadataKeys);
      const metadataSourcePath = join(projectRoot, outputMetadataFilePath);

      try {
        // Ensure directory exists
        await mkdir(dirname(metadataSourcePath), { recursive: true });
        // Write metadata source file
        await writeFile(metadataSourcePath, metadataSourceContent);
      } catch (error) {
        logger.warn(`[screw-up]: Failed to write metadata source file: ${metadataSourcePath}: ${error}`);
      }
    }
  };

  return {
    name: 'screw-up',
    // Ensure screw-up runs before other plugins
    // (especially vite-plugin-dts, avoid packageMetadata.ts is not found)
    enforce: 'pre',
    // Configuration resolved phase
    configResolved: async config => {
      // Save project root
      projectRoot = config.root;
      const _logger = {
        debug: config?.logger?.info ?? config?.customLogger?.info ?? logger.debug,
        info: config?.logger?.info ?? config?.customLogger?.info ?? logger.info,
        warn: config?.logger?.warn ?? config?.customLogger?.warn ?? logger.warn,
        error: config?.logger?.error ?? config?.customLogger?.error ?? logger.error,
      };
      logger = _logger;
      // Get Git metadata fetcher function
      fetchGitMetadata = getFetchGitMetadata(
        projectRoot, checkWorkingDirectoryStatus, logger);
      // Generate metadata TypeScript file early to ensure it's available during TypeScript compilation
      await generateMetadataSourceFile();
    },
    // Build start phase
    buildStart: async () => {
      // Re-resolve package metadata to capture any changes since configResolved
      // Update metadata TypeScript file with latest data
      await generateMetadataSourceFile();
    },
    // Generate bundle phase
    generateBundle: (_options, bundle) => {
      // Add banner to each output file if enabled
      if (insertMetadataBanner) {
        for (const fileName in bundle) {
          const chunk = bundle[fileName];
          if (chunk.type === 'chunk') {
            chunk.code = insertBannerHeader(chunk.code, banner);
          } else if (chunk.type === 'asset' && assetFiltersRegex.some(filter => filter.test(fileName))) {
            if (typeof chunk.source === 'string') {
              chunk.source = insertBannerHeader(chunk.source, banner + '\n');  // insert more blank line
            }
          }
        }
      }
    },
    // Write bundle phase
    writeBundle: async options => {
      // Handle files written by other plugins (like vite-plugin-dts) if banner insertion is enabled
      if (!insertMetadataBanner || !options.dir) return;

      try {
        // Read all files in the output directory
        const files = await readdir(options.dir, { recursive: true });

        // Iterate over all files
        for (const file of files) {
          const filePath = join(options.dir, file);

          // Check if the file is target asset file
          if (assetFiltersRegex.some(filter => filter.test(file))) {
            try {
              // Read the asset file
              const content = await readFile(filePath, 'utf-8');
              // Append banner to the asset file if it doesn't already contain it
              if (!content.includes(banner)) {
                await writeFile(filePath, insertBannerHeader(content, banner + '\n'));
              }
            } catch (error) {
              // Skip files that can't be read/written
            }
          }
        }
      } catch (error) {
        // Skip files that can't be read/written
      }
    }
  };
};
