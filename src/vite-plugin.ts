// screw-up - Easy package metadata inserter on Vite plugin
// Copyright (c) Kouji Matsui (@kekyo@mi.kekyo.net)
// Under MIT.
// https://github.com/kekyo/screw-up/

import type { Plugin } from "vite";
import { readFile, writeFile, readdir, mkdir } from "fs/promises";
import { existsSync } from "fs";
import { join, dirname } from "path";
import { createAsyncLock } from "async-primitives";
import { resolvePackageMetadata, createConsoleLogger } from "./internal";
import { ScrewUpOptions, PackageMetadata } from "./types";
import { getFetchGitMetadata } from "./analyzer";
import { git_commit_hash, name, version } from "./generated/packageMetadata";

/**
 * Generate banner string from package.json metadata
 * @param metadata - Package metadata
 * @param outputKeys - Array of keys to output in specified order
 * @returns Banner string
 */
export const generateBanner = (
  metadata: PackageMetadata,
  outputKeys: string[],
): string => {
  const parts: string[] = [];

  for (const key of outputKeys) {
    const value = metadata[key];
    if (value) {
      parts.push(`${key}: ${value}`);
    }
  }

  return parts.length > 0 ? `/*!\n * ${parts.join("\n * ")}\n */` : "";
};

/**
 * Insert banner header at appropriate position considering shebang
 * @param content - The content to insert banner into
 * @param banner - The banner header to insert
 * @returns Content with banner header inserted
 */
const insertBannerHeader = (content: string, banner: string): string => {
  const lines = content.split("\n");

  // Check if first line is shebang
  if (lines.length > 0 && lines[0].startsWith("#!")) {
    // Insert banner after shebang line
    return lines[0] + "\n" + banner + "\n" + lines.slice(1).join("\n");
  } else {
    // Insert banner at the beginning
    return banner + "\n" + content;
  }
};

/**
 * Convert string key to valid TypeScript identifier
 * @param key - The key to convert
 * @returns Valid TypeScript identifier
 */
const sanitizeKey = (key: string): string => {
  // Replace dots and other invalid characters with underscores
  return key.replace(/[^a-zA-Z0-9_]/g, "_").replace(/^(\d)/, "_$1");
};

/**
 * Generate TypeScript metadata file content from package metadata
 * @param metadata - Package metadata
 * @param outputKeys - Array of keys to output
 * @returns TypeScript file content
 */
const generateMetadataFile = (
  metadata: PackageMetadata,
  outputKeys: string[],
): string => {
  const lines: string[] = [];

  lines.push("// This file is auto-generated by screw-up plugin");
  lines.push("// Do not edit manually");
  lines.push("");

  for (const key of outputKeys) {
    const value = metadata[key];
    if (value) {
      const sanitizedKey = sanitizeKey(key);
      const escapedValue = JSON.stringify(value);
      lines.push(`export const ${sanitizedKey} = ${escapedValue};`);
    }
  }

  lines.push("");

  return lines.join("\n");
};

/**
 * Generate TypeScript type definition file content from output keys
 * @param outputKeys - Array of keys to output
 * @returns TypeScript type definition file content
 */
const generateMetadataTypeFile = (outputKeys: string[]): string => {
  const lines: string[] = [];

  lines.push("// This file is auto-generated by screw-up plugin");
  lines.push("// Do not edit manually");
  lines.push("");

  for (const key of outputKeys) {
    const sanitizedKey = sanitizeKey(key);
    lines.push(`export declare const ${sanitizedKey}: string;`);
  }

  lines.push("");

  return lines.join("\n");
};

/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Vite plugin that adds banner to the bundled code
 * @param options - Plugin options
 * @returns Vite plugin
 */
export const screwUp = (options: ScrewUpOptions = {}): Plugin => {
  const {
    outputKeys = [
      "name",
      "version",
      "description",
      "author",
      "license",
      "repository.url",
      "git.commit.hash",
    ],
    assetFilters = ["\\.d\\.ts$"],
    outputMetadataFile = false,
    outputMetadataFilePath = "src/generated/packageMetadata.ts",
    outputMetadataFileTypePath,
    outputMetadataKeys = [
      "name",
      "version",
      "description",
      "author",
      "license",
      "repository.url",
      "git.commit.hash",
    ],
    checkWorkingDirectoryStatus = true,
    alwaysOverrideVersionFromGit = true,
    insertMetadataBanner = true,
  } = options;

  const assetFiltersRegex = assetFilters.map((filter) => new RegExp(filter));

  // Generate default type definition file path if not provided
  const resolvedOutputMetadataFileTypePath =
    outputMetadataFileTypePath ||
    outputMetadataFilePath.replace(/\.ts$/, ".d.ts");
  const generateMetadataSourceLocker = createAsyncLock();

  const loggerPrefix = `${name}-vite`;
  let logger = createConsoleLogger(loggerPrefix);
  let banner: string;
  let metadata: any;
  let projectRoot: string;
  let fetchGitMetadata = () => Promise.resolve<any>({});

  // Helper function to write file if content has changed
  const writeFileIfChanged = async (
    filePath: string,
    content: string,
    description: string,
  ): Promise<boolean> => {
    try {
      // Check if file exists and compare content
      let shouldWrite = !existsSync(filePath);
      if (!shouldWrite) {
        try {
          const existingContent = await readFile(filePath, "utf-8");
          shouldWrite = existingContent !== content;
        } catch {
          // File doesn't exist or couldn't read, we should write it
          shouldWrite = true;
        }
      }

      if (shouldWrite) {
        // Ensure directory exists
        await mkdir(dirname(filePath), { recursive: true });
        // Write file only if content has changed
        await writeFile(filePath, content);
        return true;
      } else {
        // File content is the same, no need to write
        return false;
      }
    } catch (error) {
      logger.warn(`Failed to write ${description}: ${filePath}: ${error}`);
      return false;
    }
  };

  // Generate and write metadata TypeScript file
  const generateMetadataSourceFile = async () => {
    // Resolve package metadata
    const result = await resolvePackageMetadata(
      projectRoot,
      fetchGitMetadata,
      alwaysOverrideVersionFromGit,
      logger,
    );
    metadata = result.metadata;
    // Regenerate banner with updated metadata
    banner = generateBanner(metadata, outputKeys);
    if (outputMetadataFile) {
      const metadataSourceContent = generateMetadataFile(
        metadata,
        outputMetadataKeys,
      );
      const metadataSourcePath = join(projectRoot, outputMetadataFilePath);
      return await writeFileIfChanged(
        metadataSourcePath,
        metadataSourceContent,
        "metadata source file",
      );
    }
    return false;
  };

  // Generate and write metadata TypeScript type definition file
  const generateMetadataTypeDefinitionFile = async () => {
    if (outputMetadataFile) {
      const metadataTypeContent = generateMetadataTypeFile(outputMetadataKeys);
      const metadataTypePath = join(
        projectRoot,
        resolvedOutputMetadataFileTypePath,
      );
      return await writeFileIfChanged(
        metadataTypePath,
        metadataTypeContent,
        "metadata type definition file",
      );
    }
    return false;
  };

  // Generate dummy metadata TypeScript file with empty string values
  const generateDummyMetadataFile = async () => {
    if (outputMetadataFile) {
      const metadataSourcePath = join(projectRoot, outputMetadataFilePath);
      // Only generate if file doesn't exist (don't overwrite existing files)
      if (!existsSync(metadataSourcePath)) {
        // Create dummy metadata with empty strings for all keys
        const dummyMetadata: any = {};
        outputMetadataKeys.forEach((key) => {
          dummyMetadata[key] = "[Require first build]";
        });
        const dummyContent = generateMetadataFile(
          dummyMetadata,
          outputMetadataKeys,
        );
        return await writeFileIfChanged(
          metadataSourcePath,
          dummyContent,
          "dummy metadata source file",
        );
      }
    }
    return false;
  };

  return {
    name: "screw-up",
    // Ensure screw-up runs before other plugins
    // (especially vite-plugin-dts, avoid packageMetadata.ts is not found)
    enforce: "pre",
    // Plugin starting
    applyToEnvironment: async (penv) => {
      logger.info(`${version}-${git_commit_hash}: Started.`);

      // Partial (but maybe exact) project root
      projectRoot = penv.config.root;

      // Generate type definition file early since it doesn't require actual metadata values
      if (projectRoot && (await generateMetadataTypeDefinitionFile())) {
        logger.info(
          `applyToEnvironment: Metadata type definition file is generated: ${resolvedOutputMetadataFileTypePath}`,
        );
      }

      // Generate dummy metadata source file to prevent import errors on initial build
      if (projectRoot && (await generateDummyMetadataFile())) {
        logger.info(
          `applyToEnvironment: Dummy metadata source file is generated: ${outputMetadataFilePath}`,
        );
      }

      return true;
    },
    // Configuration resolved phase
    configResolved: async (config) => {
      // Avoid race conditions.
      const l = await generateMetadataSourceLocker.lock();
      try {
        logger.debug(`configResolved: Started.`);

        // Save project root
        projectRoot = config.root;
        if (config?.logger) {
          logger = createConsoleLogger(loggerPrefix, config.logger);
        } else if (config?.customLogger) {
          logger = createConsoleLogger(loggerPrefix, config.customLogger);
        }
        // Get Git metadata fetcher function
        fetchGitMetadata = getFetchGitMetadata(
          projectRoot,
          checkWorkingDirectoryStatus,
          logger,
        );
        // Generate metadata TypeScript file early to ensure it's available during TypeScript compilation
        if (await generateMetadataSourceFile()) {
          logger.info(
            `configResolved: Metadata source file is generated: ${outputMetadataFilePath}`,
          );
        }
      } finally {
        logger.debug(`configResolved: Exited.`);
        l.release();
      }
    },
    // Server hook
    configureServer: async (server) => {
      // Avoid race conditions.
      const l = await generateMetadataSourceLocker.lock();
      try {
        logger.debug(`configureServer: Started.`);

        // Exclude generated metadata file from watcher to prevent infinite loop
        if (outputMetadataFile && server.watcher) {
          const metadataSourcePath = join(projectRoot, outputMetadataFilePath);
          // Use unwatch to exclude the file from being watched
          server.watcher.unwatch(metadataSourcePath);
          logger.debug(
            `configureServer: Excluded from watcher: ${outputMetadataFilePath}`,
          );
        }

        if (await generateMetadataSourceFile()) {
          logger.info(
            `configureServer: Metadata source file is generated: ${outputMetadataFilePath}`,
          );
        }
      } finally {
        logger.debug(`configureServer: Exited.`);
        l.release();
      }
    },
    // Build start phase
    buildStart: async () => {
      // Avoid race conditions.
      const l = await generateMetadataSourceLocker.lock();
      try {
        logger.debug(`buildStart: Started.`);
        // Re-resolve package metadata to capture any changes since configResolved
        // Update metadata TypeScript file with latest data
        if (await generateMetadataSourceFile()) {
          logger.info(
            `buildStart: Metadata source file is generated: ${outputMetadataFilePath}`,
          );
        }
      } finally {
        logger.debug(`buildStart: Exited.`);
        l.release();
      }
    },
    // Generate bundle phase
    generateBundle: (_options, bundle) => {
      // Add banner to each output file if enabled
      if (insertMetadataBanner) {
        let count = 0;
        for (const fileName in bundle) {
          const chunk = bundle[fileName];
          if (chunk.type === "chunk") {
            chunk.code = insertBannerHeader(chunk.code, banner);
            count++;
          } else if (
            chunk.type === "asset" &&
            assetFiltersRegex.some((filter) => filter.test(fileName))
          ) {
            if (typeof chunk.source === "string") {
              chunk.source = insertBannerHeader(chunk.source, banner + "\n"); // insert more blank line
              count++;
            }
          }
        }
        if (count >= 1) {
          logger.debug(
            `generateBundle: Banner header inserted: ${count} file(s)`,
          );
        }
      }
    },
    // Write bundle phase
    writeBundle: async (options) => {
      // Handle files written by other plugins (like vite-plugin-dts) if banner insertion is enabled
      if (!insertMetadataBanner || !options.dir) return;

      try {
        // Read all files in the output directory
        const files = await readdir(options.dir, { recursive: true });

        // Iterate over all files
        let count = 0;
        for (const file of files) {
          const filePath = join(options.dir, file);

          // Check if the file is target asset file
          if (assetFiltersRegex.some((filter) => filter.test(file))) {
            try {
              // Read the asset file
              const content = await readFile(filePath, "utf-8");
              // Append banner to the asset file if it doesn't already contain it
              if (!content.includes(banner)) {
                await writeFile(
                  filePath,
                  insertBannerHeader(content, banner + "\n"),
                );
                count++;
              }
            } catch (error) {
              // Skip files that can't be read/written
            }
          }
        }
        if (count >= 1) {
          logger.debug(`writeBundle: Banner header inserted: ${count} file(s)`);
        }
      } catch (error) {
        // Skip files that can't be read/written
      }
    },
  };
};
