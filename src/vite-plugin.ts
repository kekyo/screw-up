// screw-up - Easy package metadata inserter on Vite plugin
// Copyright (c) Kouji Matsui (@kekyo@mi.kekyo.net)
// Under MIT.
// https://github.com/kekyo/screw-up/

import type { Plugin } from 'vite';
import type { OutputOptions } from 'rollup';
import { readFile, writeFile, readdir, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join, dirname, basename } from 'path';
import { createMutex } from 'async-primitives';
import { resolvePackageMetadata, createConsoleLogger } from './internal';
import { ScrewUpOptions, PackageMetadata } from './types';
import { getFetchGitMetadata } from './analyzer';
import { git_commit_hash, name, version } from './generated/packageMetadata';

/**
 * Generate banner string from package.json metadata
 * @param metadata - Package metadata
 * @param outputKeys - Array of keys to output in specified order
 * @returns Banner string
 */
export const generateBanner = (
  metadata: PackageMetadata,
  outputKeys: string[]
): string => {
  const parts: string[] = [];

  for (const key of outputKeys) {
    const value = metadata[key];
    if (value) {
      parts.push(`${key}: ${value}`);
    }
  }

  return parts.length > 0 ? `/*!\n * ${parts.join('\n * ')}\n */` : '';
};

/**
 * Insert banner header at appropriate position considering shebang
 * @param content - The content to insert banner into
 * @param banner - The banner header to insert
 * @returns Content with banner header inserted
 */
const insertBannerHeader = (content: string, banner: string): string => {
  const lines = content.split('\n');

  // Check if first line is shebang
  if (lines.length > 0 && lines[0].startsWith('#!')) {
    // Insert banner after shebang line
    return lines[0] + '\n' + banner + '\n' + lines.slice(1).join('\n');
  } else {
    // Insert banner at the beginning
    return banner + '\n' + content;
  }
};

/**
 * Convert string key to valid TypeScript identifier
 * @param key - The key to convert
 * @returns Valid TypeScript identifier
 */
const sanitizeKey = (key: string): string => {
  // Replace dots and other invalid characters with underscores
  return key.replace(/[^a-zA-Z0-9_]/g, '_').replace(/^(\d)/, '_$1');
};

/**
 * Generate TypeScript metadata file content from package metadata
 * @param metadata - Package metadata
 * @param outputKeys - Array of keys to output
 * @returns TypeScript file content
 */
const generateMetadataFileContent = (
  metadata: PackageMetadata,
  outputKeys: string[]
): { content: string; exportedIdentifiers: string[] } => {
  const lines: string[] = [];
  const exportedIdentifiers: string[] = [];

  lines.push('// @ts-nocheck');
  lines.push('// This file is auto-generated by screw-up plugin');
  lines.push('// Do not edit manually');
  lines.push('');

  for (const key of outputKeys) {
    const value = metadata[key];
    if (value) {
      const sanitizedKey = sanitizeKey(key);
      const escapedValue = JSON.stringify(value);
      lines.push(`export const ${sanitizedKey} = ${escapedValue};`);
      exportedIdentifiers.push(sanitizedKey);
    }
  }

  lines.push('');

  return { content: lines.join('\n'), exportedIdentifiers };
};

/**
 * Generate TypeScript type definition file content from output keys
 * @param outputKeys - Array of keys to output
 * @returns TypeScript type definition file content
 */
const generateMetadataTypeFileContent = (outputKeys: string[]): string => {
  const lines: string[] = [];

  lines.push('// This file is auto-generated by screw-up plugin');
  lines.push('// Do not edit manually');
  lines.push('');

  for (const key of outputKeys) {
    const sanitizedKey = sanitizeKey(key);
    lines.push(`export declare const ${sanitizedKey}: string;`);
  }

  lines.push('');

  return lines.join('\n');
};

/////////////////////////////////////////////////////////////////////////////////////////

/**
 * Vite plugin that adds banner to the bundled code
 * @param options - Plugin options
 * @returns Vite plugin
 */
export const screwUp = (options: ScrewUpOptions = {}): Plugin => {
  const {
    outputKeys = [
      'name',
      'version',
      'description',
      'author',
      'license',
      'repository.url',
      'git.commit.hash',
    ],
    assetFilters = ['\\.d\\.ts$'],
    outputMetadataFile = false,
    outputMetadataFilePath = 'src/generated/packageMetadata.ts',
    outputMetadataFileTypePath,
    outputMetadataKeys = [
      'name',
      'version',
      'description',
      'author',
      'license',
      'repository.url',
      'git.commit.hash',
    ],
    checkWorkingDirectoryStatus = true,
    alwaysOverrideVersionFromGit = true,
    insertMetadataBanner = true,
  } = options;

  const assetFiltersRegex = assetFilters.map((filter) => new RegExp(filter));

  // Generate default type definition file path if not provided
  const resolvedOutputMetadataTypeFilePath =
    outputMetadataFileTypePath ||
    outputMetadataFilePath.replace(/\.ts$/, '.d.ts');
  const generateMetadataSourceLocker = createMutex();

  const loggerPrefix = `${name}-vite`;
  let logger = createConsoleLogger(loggerPrefix);
  let banner = '';
  let metadata: any;
  let projectRoot: string;
  let fetchGitMetadata = () => Promise.resolve<any>({});

  // Helper function to write file if content has changed
  const writeFileIfChanged = async (
    filePath: string,
    content: string,
    description: string
  ): Promise<boolean> => {
    try {
      // Check if file exists and compare content
      let shouldWrite = !existsSync(filePath);
      if (!shouldWrite) {
        try {
          const existingContent = await readFile(filePath, 'utf-8');
          shouldWrite = existingContent !== content;
        } catch {
          // File doesn't exist or couldn't read, we should write it
          shouldWrite = true;
        }
      }

      if (shouldWrite) {
        // Ensure directory exists
        await mkdir(dirname(filePath), { recursive: true });
        // Write file only if content has changed
        await writeFile(filePath, content);
        return true;
      } else {
        // File content is the same, no need to write
        return false;
      }
    } catch (error) {
      logger.warn(`Failed to write ${description}: ${filePath}: ${error}`);
      return false;
    }
  };

  const ensureMetadataGitignore = async (
    metadataSourcePath: string
  ): Promise<boolean> => {
    const metadataDirectory = dirname(metadataSourcePath);
    const gitignorePath = join(metadataDirectory, '.gitignore');

    if (existsSync(gitignorePath)) {
      return false;
    }

    try {
      await mkdir(metadataDirectory, { recursive: true });
      const metadataFileName = basename(metadataSourcePath);
      const gitignoreContent = `# Auto-generated by screw-up plugin\n${metadataFileName}\n`;
      await writeFile(gitignorePath, gitignoreContent);
      return true;
    } catch (error) {
      logger.warn(
        `Failed to write .gitignore for metadata source: ${gitignorePath}: ${error}`
      );
      return false;
    }
  };

  // Generate and write metadata TypeScript file
  const generateMetadataSourceFiles = async () => {
    // Resolve package metadata
    const result = await resolvePackageMetadata(
      projectRoot,
      fetchGitMetadata,
      alwaysOverrideVersionFromGit,
      logger
    );
    metadata = result.metadata;
    // Regenerate banner with updated metadata
    banner = generateBanner(metadata, outputKeys);
    if (outputMetadataFile) {
      const { content: metadataSourceContent, exportedIdentifiers } =
        generateMetadataFileContent(metadata, outputMetadataKeys);
      const metadataSourcePath = join(projectRoot, outputMetadataFilePath);
      const metadataWritten = await writeFileIfChanged(
        metadataSourcePath,
        metadataSourceContent,
        'metadata source file'
      );
      const metadataTypeContent =
        generateMetadataTypeFileContent(exportedIdentifiers);
      const metadataTypePath = join(
        projectRoot,
        resolvedOutputMetadataTypeFilePath
      );
      const metadataTypeWritten = await writeFileIfChanged(
        metadataTypePath,
        metadataTypeContent,
        'metadata type definition file'
      );
      if (existsSync(metadataSourcePath)) {
        const gitignoreWritten =
          await ensureMetadataGitignore(metadataSourcePath);
        if (gitignoreWritten) {
          logger.info(
            `generateMetadataSourceFile: .gitignore is generated: ${join(
              dirname(outputMetadataFilePath),
              '.gitignore'
            )}`
          );
        }
      }
      if (metadataTypeWritten) {
        logger.info(
          `generateMetadataSourceFile: Metadata type definition file is generated: ${resolvedOutputMetadataTypeFilePath}`
        );
      }
      return metadataWritten || metadataTypeWritten;
    }
    return false;
  };

  // Generate and write metadata TypeScript type definition file
  const generateMetadataTypeDefinitionFileFromKeys = async (keys: string[]) => {
    if (outputMetadataFile) {
      const metadataTypeContent = generateMetadataTypeFileContent(keys);
      const metadataTypePath = join(
        projectRoot,
        resolvedOutputMetadataTypeFilePath
      );
      return await writeFileIfChanged(
        metadataTypePath,
        metadataTypeContent,
        'metadata type definition file'
      );
    }
    return false;
  };

  // Generate dummy metadata TypeScript file with empty string values
  const generateMetadataFileFromKeys = async (keys: string[]) => {
    if (outputMetadataFile) {
      const metadataSourcePath = join(projectRoot, outputMetadataFilePath);
      // Only generate if file doesn't exist (don't overwrite existing files)
      if (!existsSync(metadataSourcePath)) {
        // Create dummy metadata with empty strings for all keys
        const dummyMetadata: any = {};
        keys.forEach((key) => {
          dummyMetadata[key] = '[Require first build]';
        });
        const { content: dummyContent } = generateMetadataFileContent(
          dummyMetadata,
          keys
        );
        return await writeFileIfChanged(
          metadataSourcePath,
          dummyContent,
          'dummy metadata source file'
        );
      }
    }
    return false;
  };

  return {
    name: 'screw-up',
    // Ensure screw-up runs before other plugins
    // (especially vite-plugin-dts, avoid packageMetadata.ts is not found)
    enforce: 'pre',
    // Plugin starting
    applyToEnvironment: async (penv) => {
      // Prime metadata generation once so dependent files are ready immediately
      logger.info(`${version}-${git_commit_hash}: Started.`);

      // Partial (but maybe exact) project root
      projectRoot = penv.config.root;

      // Generate dummy type definition file early since it doesn't require actual metadata values
      if (
        projectRoot &&
        (await generateMetadataTypeDefinitionFileFromKeys(outputMetadataKeys))
      ) {
        logger.info(
          `applyToEnvironment: Metadata type definition file is generated: ${resolvedOutputMetadataTypeFilePath}`
        );
      }

      // Generate dummy metadata source file to prevent import errors on initial build
      if (
        projectRoot &&
        (await generateMetadataFileFromKeys(outputMetadataKeys))
      ) {
        logger.info(
          `applyToEnvironment: Dummy metadata source file is generated: ${outputMetadataFilePath}`
        );
      }

      return true;
    },
    // Build configuration phase
    config: (config) => {
      // Branch: When banner injection is disabled, leave rollup output untouched
      if (!insertMetadataBanner) {
        return;
      }

      config.build ??= {};
      const rollupOptions = (config.build.rollupOptions ??= {});
      // Normalize rollup outputs to an array so we can inject a banner even when empty
      const ensureOutputs = (): OutputOptions[] => {
        // Branch: Consumer already supplied an array of outputs (possibly empty)
        if (Array.isArray(rollupOptions.output)) {
          const outputs = rollupOptions.output as OutputOptions[];
          // Branch: Array exists but contains no entry yet; create one lazily
          if (outputs.length === 0) {
            const output: OutputOptions = {};
            outputs.push(output);
            return outputs;
          }
          outputs.forEach((output, index) => {
            // Branch: Array slot is nullish (user emptied it); replace with object to keep consistent
            if (!output) {
              outputs[index] = {};
            }
          });
          return outputs;
        }

        // Branch: Single output object was provided; wrap it to unify processing
        if (rollupOptions.output) {
          return [rollupOptions.output as OutputOptions];
        }

        // Branch: No output specified at all; create placeholder so banner hook can run
        const output: OutputOptions = {};
        rollupOptions.output = output;
        return [output];
      };

      const outputs = ensureOutputs();

      outputs.forEach((output) => {
        const previousBanner = output.banner;
        // Preserve any existing banner configuration and append ours later in order
        const resolvePreviousBanner = async (chunk: any) => {
          // Branch: User provided banner as function; resolve it per chunk for compatibility
          if (typeof previousBanner === 'function') {
            const resolved = await previousBanner(chunk);
            return resolved ?? '';
          }
          return previousBanner ?? '';
        };

        output.banner = async (chunk: any) => {
          const existingBanner = await resolvePreviousBanner(chunk);
          const currentBanner = banner ?? '';
          // If we have not generated the banner yet, fall back to the previous setting
          if (!currentBanner) {
            return existingBanner;
          }
          if (!existingBanner) {
            return currentBanner;
          }
          // Avoid duplicating when the existing banner already starts with our content
          if (existingBanner.startsWith(currentBanner)) {
            return existingBanner;
          }
          return `${currentBanner}\n${existingBanner}`;
        };
      });
    },
    // Configuration resolved phase
    configResolved: async (config) => {
      // Avoid race conditions.
      const l = await generateMetadataSourceLocker.lock();
      try {
        // Enable debug logging for performance analysis
        const tempEnableLogging = true;

        // Save project root
        projectRoot = config.root;
        if (tempEnableLogging || config?.logger) {
          logger = createConsoleLogger(loggerPrefix, config.logger);
        } else if (config?.customLogger) {
          logger = createConsoleLogger(loggerPrefix, config.customLogger);
        }

        logger.debug(`configResolved: Started.`);
        // Get Git metadata fetcher function
        fetchGitMetadata = getFetchGitMetadata(
          projectRoot,
          checkWorkingDirectoryStatus,
          logger
        );
        // Refresh banner string and generated files before TypeScript compilation kicks in
        // Generate metadata TypeScript file early to ensure it's available during TypeScript compilation
        if (await generateMetadataSourceFiles()) {
          logger.info(
            `configResolved: Metadata source file is generated: ${outputMetadataFilePath}`
          );
        }
      } finally {
        logger.debug(`configResolved: Exited.`);
        l.release();
      }
    },
    // Server hook
    configureServer: async (server) => {
      // Avoid race conditions.
      const l = await generateMetadataSourceLocker.lock();
      try {
        logger.debug(`configureServer: Started.`);

        // Exclude generated metadata file from watcher to prevent infinite loop
        // Branch: Metadata file output is enabled and watcher is present; unwatch to avoid churn
        if (outputMetadataFile && server.watcher) {
          const metadataSourcePath = join(projectRoot, outputMetadataFilePath);
          // Use unwatch to exclude the file from being watched
          server.watcher.unwatch(metadataSourcePath);
          logger.debug(
            `configureServer: Excluded from watcher: ${outputMetadataFilePath}`
          );
        }

        // Rebuild banner metadata on dev server startup to keep values fresh
        if (await generateMetadataSourceFiles()) {
          logger.info(
            `configureServer: Metadata source file is generated: ${outputMetadataFilePath}`
          );
        }
      } finally {
        logger.debug(`configureServer: Exited.`);
        l.release();
      }
    },
    // Build start phase
    buildStart: async () => {
      // Avoid race conditions.
      const l = await generateMetadataSourceLocker.lock();
      try {
        logger.debug(`buildStart: Started.`);
        // Re-resolve package metadata to capture any changes since configResolved
        // Update metadata TypeScript file with latest data
        if (await generateMetadataSourceFiles()) {
          logger.info(
            `buildStart: Metadata source file is generated: ${outputMetadataFilePath}`
          );
        }
      } finally {
        logger.debug(`buildStart: Exited.`);
        l.release();
      }
    },
    // Generate bundle phase
    generateBundle: (_options, bundle) => {
      // Add banner to each output file if enabled
      if (insertMetadataBanner) {
        let count = 0;
        for (const fileName in bundle) {
          const chunk = bundle[fileName];
          if (
            // Branch: Only treat assets that match filters; JS chunks already handled via rollup banner
            chunk.type === 'asset' &&
            assetFiltersRegex.some((filter) => filter.test(fileName))
          ) {
            if (typeof chunk.source === 'string') {
              // Assets are not covered by rollup banner injection, so prepend manually
              chunk.source = insertBannerHeader(chunk.source, banner + '\n'); // insert more blank line
              count++;
            }
          }
        }
        if (count >= 1) {
          logger.debug(
            `generateBundle: Banner header inserted: ${count} file(s)`
          );
        }
      }
    },
    // Write bundle phase
    writeBundle: async (options) => {
      // Handle files written by other plugins (like vite-plugin-dts) if banner insertion is enabled
      if (!insertMetadataBanner || !options.dir) return;

      try {
        // Read all files in the output directory
        const files = await readdir(options.dir, { recursive: true });

        // Iterate over all files
        let count = 0;
        for (const file of files) {
          const filePath = join(options.dir, file);

          // Check if the file is target asset file
          // Branch: Apply banner only to filtered assets in post-write stage
          if (assetFiltersRegex.some((filter) => filter.test(file))) {
            try {
              // Read the asset file
              const content = await readFile(filePath, 'utf-8');
              // Append banner to the asset file if it doesn't already contain it
              if (!content.includes(banner)) {
                // Backfill banners onto assets emitted by other plugins as well
                await writeFile(
                  filePath,
                  insertBannerHeader(content, banner + '\n')
                );
                count++;
              }
            } catch (error) {
              // Skip files that can't be read/written
            }
          }
        }
        if (count >= 1) {
          logger.debug(`writeBundle: Banner header inserted: ${count} file(s)`);
        }
      } catch (error) {
        // Skip files that can't be read/written
      }
    },
  };
};
